{
    "language": "Solidity",
    "sources": {
      "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
      },
      "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
      },
      "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
      },
      "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
      },
      "contracts/interfaces/IAllocationManager.sol": {
        "content": "\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IAllocationManager {\n/**\n *  @notice Called by an AVS to emit an `AVSMetadataURIUpdated` event indicating the information has updated.\n     *\n     *  @param metadataURI The URI for metadata associated with an AVS.\n     *\n     *  @dev Note that the `metadataURI` is *never stored* and is only emitted in the `AVSMetadataURIUpdated` event.\n     */\n    function updateAVSMetadataURI(address avs, string calldata metadataURI) external;\n}"
      },
      "contracts/interfaces/IVerisenseAVSManager.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IDelegationManager } from \"eigenlayer-contracts/src/contracts/interfaces/IDelegationManager.sol\";\nimport { ISignatureUtils } from \"eigenlayer-contracts/src/contracts/interfaces/ISignatureUtils.sol\";\nimport { IAVSDirectory } from \"eigenlayer-contracts/src/contracts/interfaces/IAVSDirectory.sol\";\nimport { IRewardsCoordinator } from \"eigenlayer-contracts/src/contracts/interfaces/IRewardsCoordinator.sol\";\nimport { IEigenPod } from \"eigenlayer-contracts/src/contracts/interfaces/IEigenPod.sol\";\nimport { IEigenPodManager } from \"eigenlayer-contracts/src/contracts/interfaces/IEigenPodManager.sol\";\n\n/**\n * @title IVerisenseAVSManager\n * @notice Interface for the VerisenseAVSManager contract, which manages operators and validators in the Verisense AVS.\n * @dev This interface defines the main functions and events for operator and validator management.\n */\ninterface IVerisenseAVSManager {\n    /**\n     * @title ValidatorData\n     * @notice Struct to store information about a validator in the Verisense AVS system.\n     * @dev This struct is used to keep track of important validator details.\n     */\n    struct ValidatorData {\n        /// @notice The address of the EigenPod associated with this validator.\n        address eigenPod;\n        /// @notice The beacon chain validator index.\n        uint64 index;\n        /// @notice The address of the operator managing this validator.\n        address operator;\n        /// @notice The block number until which the validator is registered.\n        uint64 registeredUntil;\n    }\n\n    struct OperatorValidData {\n        address operator;\n        uint256 stake;\n        bytes32 substratePubkey;\n        address[] restakedStrategies;\n    }\n\n    /**\n     * @title OperatorData\n     * @notice Struct to store information about an operator in the Verisense AVS system.\n     * @dev This struct is used to keep track of important operator details.\n     */\n    struct OperatorData {\n        /// @notice The block number when the operator started the deregistration process.\n        uint64 startDeregisterOperatorBlock;\n        /// @notice pubkey for substate block\n        bytes32 substrate_pubkey;\n\n        bool isRegistered;\n    }\n\n    /**\n     * @title ValidatorDataExtended\n     * @notice Struct to store comprehensive information about a validator.\n     * @dev This struct combines ValidatorData with additional status information.\n     */\n    struct ValidatorDataExtended {\n        /// @notice The address of the operator this validator is delegated to.\n        address operator;\n        /// @notice The address of the validator's EigenPod.\n        address eigenPod;\n        /// @notice The index of the validator in the beacon chain.\n        uint64 validatorIndex;\n        /// @notice The current status of the validator in the EigenPod.\n        IEigenPod.VALIDATOR_STATUS status;\n        /// @notice The delegate key currently associated with the validator's operator.\n        bytes delegateKey;\n        /// @notice Chain IDs the validator's operator is committed to.\n        uint256[] chainIds;\n        /// @notice Indicates whether the validator's EigenPod is currently delegated to the operator.\n        bool backedByStake;\n        /// @notice Indicates whether the validator is currently registered (current block < registeredUntil).\n        bool registered;\n    }\n\n    /**\n     * @title OperatorDataExtended\n     * @notice Struct to store extended information about an operator in the Verisense AVS system.\n     * @dev This struct combines OperatorData with additional status information.\n     */\n    struct OperatorDataExtended {\n        /// @notice The block number when the operator started the deregistration process.\n        uint128 startDeregisterOperatorBlock;\n        /// @notice Whether the operator is registered or not.\n        bool isRegistered;\n    }\n    // 7 bytes padding here (automatically added by the compiler)\n\n    /// @notice Thrown when an operator attempts to deregister while still having validators\n    error OperatorHasValidators();\n\n    /// @notice Thrown when a non-operator attempts an operator-only action\n    error NotOperator();\n\n    /// @notice Thrown when an EigenPod does not exist for a given address\n    error NoEigenPod();\n\n    /// @notice Thrown when trying to finish deregistering an operator before the delay has elapsed\n    error DeregistrationDelayNotElapsed();\n\n    /// @notice Thrown when attempting to start deregistering an operator that has already started\n    error DeregistrationAlreadyStarted();\n\n    /// @notice Thrown when trying to finish deregistering an operator that hasn't started\n    error DeregistrationNotStarted();\n\n    /// @notice Thrown when an address is not delegated to the expected operator\n    error NotDelegatedToOperator();\n\n    /// @notice Thrown when a validator is not in the active state\n    error ValidatorNotActive();\n\n    /// @notice Thrown when an action requires a registered operator, but the operator is not registered\n    error OperatorNotRegistered();\n\n    /// @notice Thrown when a non-operator attempts to deregister a validator\n    error NotValidatorOperator();\n\n    /// @notice Thrown when attempting to register a validator that is already registered\n    error ValidatorAlreadyRegistered();\n\n    /// @notice Thrown when an operator's delegate key is not set\n    error DelegateKeyNotSet();\n\n    /// @notice Thrown when trying to update an operator commitment before the change delay has passed\n    error CommitmentChangeNotReady();\n\n    /// @notice Thrown when attempting to deregister a validator that is already deregistered\n    error ValidatorAlreadyDeregistered();\n\n    /// @notice Thrown when a restaking strategy allowlist update fails\n    error RestakingStrategyAllowlistUpdateFailed();\n\n    /// @notice Thrown when an AVS operator status call fails\n    error AVSOperatorStatusCallFailed();\n\n    /// @notice Thrown when an invalid EigenPodManager address is provided\n    error InvalidEigenPodManagerAddress();\n\n    /// @notice Thrown when an invalid EigenDelegationManager address is provided\n    error InvalidEigenDelegationManagerAddress();\n\n    /// @notice Thrown when an invalid AVSDirectory address is provided\n    error InvalidAVSDirectoryAddress();\n\n    /// @notice Thrown when an invalid RewardsCoordinator address is provided\n    error InvalidRewardsCoordinatorAddress();\n\n    /**\n     * @notice Emitted when a new operator is registered in the Verisense AVS.\n     * @param operator The address of the registered operator.\n     */\n    event OperatorRegistered(address indexed operator);\n\n    /**\n     * @notice Emitted when a new validator is registered in the Verisense AVS .\n     * @param podOwner The address of the validator's EigenPod owner.\n     * @param delegateKey The delegate public key for the validator.\n     * @param blsPubKeyHash The BLS public key hash of the validator.\n     * @param validatorIndex The beacon chain validator index.\n     */\n    event ValidatorRegistered(\n        address indexed podOwner,\n        address indexed operator,\n        bytes delegateKey,\n        bytes32 blsPubKeyHash,\n        uint256 validatorIndex\n    );\n\n    /**\n     * @notice Emitted when an operator starts the deregistration process.\n     * @param operator The address of the operator starting deregistration.\n     */\n    event OperatorDeregisterStarted(address indexed operator);\n\n    /**\n     * @notice Emitted when an operator is deregistered from the Verisense AVS.\n     * @param operator The address of the deregistered operator.\n     */\n    event OperatorDeregistered(address indexed operator);\n\n    /**\n     * @notice Emitted when a validator is deregistered from the Verisense AVS.\n     * @param operator The address of the operator managing the validator.\n     * @param blsPubKeyHash The BLS public key hash of the deregistered validator.\n     */\n    event ValidatorDeregistered(address indexed operator, bytes32 blsPubKeyHash);\n\n\n    /**\n     * @notice Emitted when the deregistration delay is updated.\n     * @param oldDelay The previous deregistration delay value.\n     * @param newDelay The new deregistration delay value.\n     */\n    event DeregistrationDelaySet(uint64 oldDelay, uint64 newDelay);\n\n    /**\n     * @notice Emitted when a restaking strategy is added or removed from the allowlist.\n     * @param strategy The address of the strategy.\n     * @param allowed Whether the strategy is allowed (true) or disallowed (false).\n     */\n    event RestakingStrategyAllowlistUpdated(address indexed strategy, bool allowed);\n\n    /**\n     * @notice Emitted when operator rewards are submitted.\n     */\n    event OperatorRewardsSubmitted();\n\n    /**\n     * @notice Returns the EigenPodManager contract.\n     * @return IEigenPodManager The EigenPodManager contract.\n     */\n    function EIGEN_POD_MANAGER() external view returns (IEigenPodManager);\n\n    /**\n     * @notice Returns the EigenDelegationManager contract.\n     * @return IDelegationManager The EigenDelegationManager contract.\n     */\n    function EIGEN_DELEGATION_MANAGER() external view returns (IDelegationManager);\n\n    /**\n     * @notice Returns the AVSDirectory contract.\n     * @return IAVSDirectory The AVSDirectory contract.\n     */\n    function AVS_DIRECTORY() external view returns (IAVSDirectory);\n\n    /**\n     * @notice Registers a new operator in the Verisense AVS.\n     * @param operatorSignature The signature and associated data for operator registration.\n     */\n    function registerOperator(ISignatureUtils.SignatureWithSaltAndExpiry memory operatorSignature, bytes32 substrate_pubkey) external;\n\n    /**\n     * @notice Starts the process of deregistering an operator from the Verisense AVS.\n     */\n    function startDeregisterOperator() external;\n\n    /**\n     * @notice Finishes the process of deregistering an operator from the Verisense AVS.\n     */\n    function finishDeregisterOperator() external;\n\n    /**\n     * @notice Updates the metadata URI for the AVS\n     * @param _metadataURI is the metadata URI for the AVS\n     */\n    function updateAVSMetadataURI(string memory _metadataURI) external;\n\n    /**\n     * @notice Sets a new deregistration delay for operators.\n     * @param newDelay The new deregistration delay in seconds.\n     * @dev Restricted to the DAO\n     */\n    function setDeregistrationDelay(uint64 newDelay) external;\n\n    /**\n     * @notice Add or remove a strategy address from the allowlist of restaking strategies\n     * @param strategy The address of the strategy to add or remove\n     * @param allowed Whether the strategy should be allowed (true) or disallowed (false)\n     * @dev Restricted to the DAO\n     */\n    function setAllowlistRestakingStrategy(address strategy, bool allowed) external;\n\n    /**\n     * @notice Retrieves information about a specific operator.\n     * @param operator The address of the operator.\n     * @return OperatorDataExtended struct containing information about the operator.\n     */\n    function getOperator(address operator) external view returns (OperatorDataExtended memory);\n\n    /**\n     * @notice Retrieves the current deregistration delay for operators.\n     * @return The current deregistration delay in seconds.\n     */\n    function getDeregistrationDelay() external view returns (uint64);\n\n    /**\n     * @notice Returns the list of strategies that the operator has potentially restaked on the AVS\n     * @param operator The address of the operator to get restaked strategies for\n     * @dev This function is intended to be called off-chain\n     * @dev No guarantee is made on whether the operator has shares for a strategy in a quorum or uniqueness\n     *      of each element in the returned array. The off-chain service should do that validation separately\n     */\n    function getOperatorRestakedStrategies(address operator) external view returns (address[] memory);\n\n    /**\n     * @notice Returns the list of strategies that the AVS supports for restaking\n     * @dev This function is intended to be called off-chain\n     * @dev No guarantee is made on uniqueness of each element in the returned array.\n     *      The off-chain service should do that validation separately\n     */\n    function getRestakeableStrategies() external view returns (address[] memory);\n\n    /**\n     * @notice Submits EigenLayer rewards for operators.\n     * @param eraIndex The era index of submissions.\n     * @param submissions The array of rewards submissions.\n     */\n    function submitOperatorRewards(uint256 eraIndex, IRewardsCoordinator.OperatorDirectedRewardsSubmission[] calldata submissions)\n        external;\n\n    function latestRewardedEra() external view returns (uint256);\n\n    /**\n     * @notice Sets the claimer for the AVS to get excess rewards back.\n     * @param claimer The address of the claimer.\n     */\n    function setClaimerFor(address claimer) external;\n}\n"
      },
      "contracts/VerisenseAVSManager.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { EnumerableMap } from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport { ISignatureUtils } from \"eigenlayer-contracts/src/contracts/interfaces/ISignatureUtils.sol\";\nimport { IStrategy } from \"eigenlayer-contracts/src/contracts/interfaces/IStrategy.sol\";\nimport { IAVSDirectory } from \"eigenlayer-contracts/src/contracts/interfaces/IAVSDirectory.sol\";\nimport { IDelegationManager } from \"eigenlayer-contracts/src/contracts/interfaces/IDelegationManager.sol\";\nimport { IEigenPodManager } from \"eigenlayer-contracts/src/contracts/interfaces/IEigenPodManager.sol\";\nimport { IEigenPod } from \"eigenlayer-contracts/src/contracts/interfaces/IEigenPod.sol\";\nimport {IVerisenseAVSManager} from \"./interfaces/IVerisenseAVSManager.sol\";\nimport {VerisenseAVSManagerStorage} from \"./VerisenseAVSManagerStorage.sol\";\nimport { IRewardsCoordinator } from \"eigenlayer-contracts/src/contracts/interfaces/IRewardsCoordinator.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IAllocationManager} from \"./interfaces/IAllocationManager.sol\";\n\ncontract VerisenseAVSManager is VerisenseAVSManagerStorage, UUPSUpgradeable, OwnableUpgradeable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20 for IERC20;\n    IEigenPodManager public EIGEN_POD_MANAGER;\n\n    IDelegationManager public EIGEN_DELEGATION_MANAGER;\n\n    IRewardsCoordinator public EIGEN_REWARDS_COORDINATOR;\n\n    IAVSDirectory public AVS_DIRECTORY;\n\n    function _getAvsOperatorStatus(address operator)\n        internal\n        view\n        returns (IAVSDirectory.OperatorAVSRegistrationStatus)\n    {\n        (bool success, bytes memory data) = address(AVS_DIRECTORY).staticcall(\n            abi.encodeWithSelector(bytes4(keccak256(\"avsOperatorStatus(address,address)\")), address(this), operator)\n        );\n        if (!success) {\n            revert AVSOperatorStatusCallFailed();\n        }\n        return abi.decode(data, (IAVSDirectory.OperatorAVSRegistrationStatus));\n    }\n\n    modifier registeredOperator(address operator) {\n        if (_getAvsOperatorStatus(operator) == IAVSDirectory.OperatorAVSRegistrationStatus.UNREGISTERED) {\n            revert OperatorNotRegistered();\n        }\n        _;\n    }\n\n    function initialize(\n        address eigenPodManagerAddress,\n        address eigenDelegationManagerAddress,\n        address avsDirectoryAddress,\n        address rewardsCoordinatorAddress,\n        uint64 initialDeregistrationDelay) public initializer {\n        if (eigenPodManagerAddress == address(0)) {\n            revert InvalidEigenPodManagerAddress();\n        }\n        if (eigenDelegationManagerAddress == address(0)) {\n            revert InvalidEigenDelegationManagerAddress();\n        }\n        if (avsDirectoryAddress == address(0)) {\n            revert InvalidAVSDirectoryAddress();\n        }\n        if (rewardsCoordinatorAddress == address(0)) {\n            revert InvalidRewardsCoordinatorAddress();\n        }\n        EIGEN_POD_MANAGER = IEigenPodManager(eigenPodManagerAddress);\n        EIGEN_DELEGATION_MANAGER = IDelegationManager(eigenDelegationManagerAddress);\n        AVS_DIRECTORY = IAVSDirectory(avsDirectoryAddress);\n        EIGEN_REWARDS_COORDINATOR = IRewardsCoordinator(rewardsCoordinatorAddress);\n        _setDeregistrationDelay(initialDeregistrationDelay);\n        __Ownable_init(msg.sender);\n        __UUPSUpgradeable_init();\n    }\n\n    function registerOperator(ISignatureUtils.SignatureWithSaltAndExpiry calldata operatorSignature, bytes32 substrate_pubkey)\n        external\n    {\n        AVS_DIRECTORY.registerOperatorToAVS(msg.sender, operatorSignature);\n        _getVerisenseAVSManagerStorage().operators[msg.sender].substrate_pubkey = substrate_pubkey;\n        _getVerisenseAVSManagerStorage().operatorAddresses.add(msg.sender);\n        emit OperatorRegistered(msg.sender);\n    }\n\n    function startDeregisterOperator() external registeredOperator(msg.sender) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n\n        OperatorData storage operator = $.operators[msg.sender];\n\n        if (operator.startDeregisterOperatorBlock != 0) {\n            revert DeregistrationAlreadyStarted();\n        }\n\n        operator.startDeregisterOperatorBlock = uint64(block.number);\n\n        emit OperatorDeregisterStarted(msg.sender);\n    }\n\n    function finishDeregisterOperator() external registeredOperator(msg.sender) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n\n        OperatorData storage operator = $.operators[msg.sender];\n\n        if (operator.startDeregisterOperatorBlock == 0) {\n            revert DeregistrationNotStarted();\n        }\n\n        if (block.number < operator.startDeregisterOperatorBlock + $.deregistrationDelay) {\n            revert DeregistrationDelayNotElapsed();\n        }\n\n        AVS_DIRECTORY.deregisterOperatorFromAVS(msg.sender);\n\n        delete $.operators[msg.sender];\n        $.operatorAddresses.remove(msg.sender);\n\n        emit OperatorDeregistered(msg.sender);\n    }\n\n    function setDeregistrationDelay(uint64 newDelay) external onlyOwner {\n        _setDeregistrationDelay(newDelay);\n    }\n\n    function updateAVSMetadataURI(string memory _metadataURI) external onlyOwner {\n        AVS_DIRECTORY.updateAVSMetadataURI(_metadataURI);\n    }\n\n    function setAllowlistRestakingStrategy(address strategy, bool allowed) external onlyOwner {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        bool success;\n        if (allowed) {\n            success = $.allowlistedRestakingStrategies.add(strategy);\n        } else {\n            success = $.allowlistedRestakingStrategies.remove(strategy);\n        }\n        if (success) {\n            emit RestakingStrategyAllowlistUpdated(strategy, allowed);\n        } else {\n            revert RestakingStrategyAllowlistUpdateFailed();\n        }\n    }\n\n    function _updateLatestRewardedEra(uint256 eraIndex) internal {\n        require(eraIndex > 0, \"reward era must more than 0\");\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        if ($.latestRewardedEra == 0) {\n            $.latestRewardedEra = eraIndex;\n        } else {\n            require(eraIndex == $.latestRewardedEra + 1, \"latest rewarded era must be in a row\");\n            $.latestRewardedEra = eraIndex;\n        }\n    }\n\n    function latestRewardedEra() external view returns (uint256) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        return $.latestRewardedEra;\n    }\n\n    function submitOperatorRewards(uint256 eraIndex, IRewardsCoordinator.OperatorDirectedRewardsSubmission[] calldata submissions)\n        external\n        onlyOwner\n    {\n        _updateLatestRewardedEra(eraIndex);\n        uint256 submissionsLength = submissions.length;\n        for (uint256 i = 0; i < submissionsLength; i++) {\n            IRewardsCoordinator.OperatorDirectedRewardsSubmission calldata submission = submissions[i];\n            uint256 totalRewards = 0;\n            uint256 rewardsLength = submission.operatorRewards.length;\n            for (uint256 j = 0; j < rewardsLength; j++) {\n                totalRewards += submission.operatorRewards[j].amount;\n            }\n            IERC20(address(submission.token)).safeIncreaseAllowance(address(EIGEN_REWARDS_COORDINATOR), totalRewards);\n        }\n        EIGEN_REWARDS_COORDINATOR.createOperatorDirectedAVSRewardsSubmission(address(this), submissions);\n        emit OperatorRewardsSubmitted();\n    }\n\n    function setClaimerFor(address claimer) external onlyOwner {\n        EIGEN_REWARDS_COORDINATOR.setClaimerFor(claimer);\n    }\n\n    function getDeregistrationDelay() external view returns (uint64) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        return $.deregistrationDelay;\n    }\n\n    function updateAVSMetadata(address allocation_addr, string calldata uri) external onlyOwner {\n        IAllocationManager(allocation_addr).updateAVSMetadataURI(address(this), uri);\n    }\n\n    function getOperator(address operator) external view returns (OperatorDataExtended memory) {\n        return _getOperator(operator);\n    }\n\n    function _getOperatorRestakedStrategies(address operator) internal view\n                    returns (address[] memory restakedStrategies) {\n        OperatorDataExtended memory operatorData = _getOperator(operator);\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n\n        if (operatorData.isRegistered) {\n            uint256 allowlistedCount = $.allowlistedRestakingStrategies.length();\n            IStrategy[] memory strategies = new IStrategy[](allowlistedCount);\n            for (uint256 i = 0; i < allowlistedCount; i++) {\n                strategies[i] = IStrategy($.allowlistedRestakingStrategies.at(i));\n            }\n\n            uint256[] memory shares = EIGEN_DELEGATION_MANAGER.getOperatorShares(operator, strategies);\n\n            uint256 restakedCount = 0;\n            restakedStrategies = new address[](allowlistedCount);\n\n            for (uint256 i = 0; i < allowlistedCount; i++) {\n                if (shares[i] > 0) {\n                    restakedStrategies[restakedCount++] = address(strategies[i]);\n                }\n            }\n\n            // Resize the array to the actual number of restaked strategies\n            assembly {\n                if lt(restakedCount, allowlistedCount) { mstore(restakedStrategies, restakedCount) }\n            }\n        }\n    }\n\n    function getOperators() external view returns (OperatorValidData[] memory operatorList) {\n        uint256 operators_size = _getVerisenseAVSManagerStorage().operatorAddresses.length();\n        operatorList = new OperatorValidData[](operators_size);\n        IStrategy[] memory strategies = _getStrategies();\n        uint256 registeredCount = 0;\n        for (uint256 i = 0; i < operators_size; i++) {\n            address key = _getVerisenseAVSManagerStorage().operatorAddresses.at(i);\n            if (_getAvsOperatorStatus(key) == IAVSDirectory.OperatorAVSRegistrationStatus.REGISTERED) {\n                OperatorData memory d = _getVerisenseAVSManagerStorage().operators[key];\n                OperatorValidData memory dv = OperatorValidData({\n                    substratePubkey : d.substrate_pubkey,\n                    operator : key,\n                    stake : _getOperatorStake(key, strategies),\n                    restakedStrategies : sortAddresses(_getOperatorRestakedStrategies(key))\n                });\n                operatorList[registeredCount++] = dv;\n            }\n        }\n        assembly {\n            if lt(registeredCount, operators_size) { mstore(operatorList, registeredCount) }\n        }\n    }\n\n    function getOperatorRestakedStrategies(address operator)\n        external\n        view\n        returns (address[] memory restakedStrategies)\n    {\n       return _getOperatorRestakedStrategies(operator);\n    }\n\n    function _getOperatorStake(address operator, IStrategy[] memory strategies) internal view returns (uint256) {\n        uint256[] memory shares = EIGEN_DELEGATION_MANAGER.getOperatorShares(operator, strategies);\n        uint256 total_shares = 0;\n        for (uint256 i = 0; i < shares.length; i++) {\n            total_shares += shares[i];\n        }\n        return total_shares;\n    }\n\n    function _getStrategies() internal view returns (IStrategy[] memory) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        uint256 allowlistedCount = $.allowlistedRestakingStrategies.length();\n        IStrategy[] memory strategies = new IStrategy[](allowlistedCount);\n        for (uint256 i = 0; i < allowlistedCount; i++) {\n            strategies[i] = IStrategy($.allowlistedRestakingStrategies.at(i));\n        }\n        return strategies;\n    }\n\n    function getRestakeableStrategies() external view returns (address[] memory) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        return $.allowlistedRestakingStrategies.values();\n    }\n\n    function _getOperator(address operator) internal view returns (OperatorDataExtended memory) {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        OperatorData storage operatorData = $.operators[operator];\n        return OperatorDataExtended({\n            startDeregisterOperatorBlock: operatorData.startDeregisterOperatorBlock,\n            isRegistered: _getAvsOperatorStatus(operator) == IAVSDirectory.OperatorAVSRegistrationStatus.REGISTERED\n        });\n    }\n\n    function _setDeregistrationDelay(uint64 newDelay) internal {\n        VerisenseAVSStorage storage $ = _getVerisenseAVSManagerStorage();\n        uint64 oldDelay = $.deregistrationDelay;\n        $.deregistrationDelay = newDelay;\n        emit DeregistrationDelaySet(oldDelay, newDelay);\n    }\n\n    function sortAddresses(address[] memory arr) internal pure returns (address[] memory) {\n        if (arr.length == 0) {\n            return arr;\n        }\n        address[] memory sortedArr = new address[](arr.length);\n        for (uint i = 0; i < arr.length; i++) {\n            sortedArr[i] = arr[i];\n        }\n        for (uint i = 0; i < sortedArr.length - 1; i++) {\n            for (uint j = 0; j < sortedArr.length - i - 1; j++) {\n                if (uint160(sortedArr[j]) > uint160(sortedArr[j + 1])) {\n                    (sortedArr[j], sortedArr[j + 1]) = (sortedArr[j + 1], sortedArr[j]);\n                }\n            }\n        }\n        return sortedArr;\n    }\n\n    function calculateOperatorAVSRegistrationDigestHash(\n        address operator,\n        address avs,\n        bytes32 salt,\n        uint256 expiry\n    ) public view returns (bytes32) {\n        bytes32 OPERATOR_AVS_REGISTRATION_TYPEHASH =\n        keccak256(\"OperatorAVSRegistration(address operator,address avs,bytes32 salt,uint256 expiry)\");\n        // calculate the struct hash\n        bytes32 sep = AVS_DIRECTORY.domainSeparator();\n        bytes32 structHash = keccak256(abi.encode(OPERATOR_AVS_REGISTRATION_TYPEHASH, operator, avs, salt, expiry));\n        // calculate the digest hash\n        bytes32 digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", sep, structHash));\n        return digestHash;\n    }\n\n    function ecdsa_check(bytes32 message_hash, bytes memory signature ) public pure returns (address) {\n        return ECDSA.recover(message_hash, signature);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner { }\n}\n"
      },
      "contracts/VerisenseAVSManagerStorage.sol": {
        "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IVerisenseAVSManager} from \"./interfaces/IVerisenseAVSManager.sol\";\n/**\n * @title VerisenseAVSManagerStorage\n * @author Puffer Finance\n * @custom:security-contact security@puffer.fi\n */\n\nabstract contract VerisenseAVSManagerStorage is IVerisenseAVSManager {\n    struct VerisenseAVSStorage {\n        mapping(address operator => OperatorData operatorData) operators;\n        EnumerableSet.AddressSet operatorAddresses;\n        uint64 deregistrationDelay;\n        uint256 stakeFloor;\n        uint256 latestRewardedEra;\n        EnumerableSet.AddressSet allowlistedRestakingStrategies;\n    }\n    bytes32 private constant _STORAGE_LOCATION = 0xaf993094c8eaa0abdffcc638bc8d87f9c9a50f945db9b99ab0b6681eab4f4f00;\n\n    function _getVerisenseAVSManagerStorage() internal pure returns (VerisenseAVSStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IAVSDirectory.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./ISignatureUtils.sol\";\n\ninterface IAVSDirectory is ISignatureUtils {\n    /// @notice Enum representing the status of an operator's registration with an AVS\n    enum OperatorAVSRegistrationStatus {\n        UNREGISTERED, // Operator not registered to AVS\n        REGISTERED // Operator registered to AVS\n\n    }\n\n    /**\n     * @notice Emitted when @param avs indicates that they are updating their MetadataURI string\n     * @dev Note that these strings are *never stored in storage* and are instead purely emitted in events for off-chain indexing\n     */\n    event AVSMetadataURIUpdated(address indexed avs, string metadataURI);\n\n    /// @notice Emitted when an operator's registration status for an AVS is updated\n    event OperatorAVSRegistrationStatusUpdated(\n        address indexed operator, address indexed avs, OperatorAVSRegistrationStatus status\n    );\n\n    /**\n     * @notice Called by the AVS's service manager contract to register an operator with the avs.\n     * @param operator The address of the operator to register.\n     * @param operatorSignature The signature, salt, and expiry of the operator's signature.\n     */\n    function registerOperatorToAVS(\n        address operator,\n        ISignatureUtils.SignatureWithSaltAndExpiry memory operatorSignature\n    ) external;\n\n    /**\n     * @notice Called by an avs to deregister an operator with the avs.\n     * @param operator The address of the operator to deregister.\n     */\n    function deregisterOperatorFromAVS(address operator) external;\n\n    /**\n     * @notice Called by an AVS to emit an `AVSMetadataURIUpdated` event indicating the information has updated.\n     * @param metadataURI The URI for metadata associated with an AVS\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `AVSMetadataURIUpdated` event\n     */\n    function updateAVSMetadataURI(string calldata metadataURI) external;\n\n    /**\n     * @notice Returns whether or not the salt has already been used by the operator.\n     * @dev Salts is used in the `registerOperatorToAVS` function.\n     */\n    function operatorSaltIsSpent(address operator, bytes32 salt) external view returns (bool);\n\n    /**\n     * @notice Calculates the digest hash to be signed by an operator to register with an AVS\n     * @param operator The account registering as an operator\n     * @param avs The address of the service manager contract for the AVS that the operator is registering to\n     * @param salt A unique and single use value associated with the approver signature.\n     * @param expiry Time after which the approver's signature becomes invalid\n     */\n    function calculateOperatorAVSRegistrationDigestHash(\n        address operator,\n        address avs,\n        bytes32 salt,\n        uint256 expiry\n    ) external view returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the Registration struct used by the contract\n    function OPERATOR_AVS_REGISTRATION_TYPEHASH() external view returns (bytes32);\n\n    /**\n     * @notice Called by an operator to cancel a salt that has been used to register with an AVS.\n     * @param salt A unique and single use value associated with the approver signature.\n     */\n    function cancelSalt(bytes32 salt) external;\n\n    /**\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\n     *\n     * @dev The domain separator will change in the event of a fork that changes the ChainID.\n     * @dev By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.\n     * for more detailed information please read EIP-712.\n     */\n    function domainSeparator() external view returns (bytes32);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IDelegationManager.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./IStrategy.sol\";\nimport \"./ISignatureUtils.sol\";\n\n/**\n * @title DelegationManager\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayer\n * - allowing operators to specify parameters related to stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice (a given staker can only delegate to a single operator at a time)\n * - enabling a staker to undelegate its assets from the operator it is delegated to (performed as part of the withdrawal process, initiated through the StrategyManager)\n */\ninterface IDelegationManager is ISignatureUtils {\n    // @notice Struct used for storing information about a single operator who has registered with EigenLayer\n    struct OperatorDetails {\n        /// @notice DEPRECATED -- this field is no longer used, payments are handled in PaymentCoordinator.sol\n        address __deprecated_earningsReceiver;\n        /**\n         * @notice Address to verify signatures when a staker wishes to delegate to the operator, as well as controlling \"forced undelegations\".\n         * @dev Signature verification follows these rules:\n         * 1) If this address is left as address(0), then any staker will be free to delegate to the operator, i.e. no signature verification will be performed.\n         * 2) If this address is an EOA (i.e. it has no code), then we follow standard ECDSA signature verification for delegations to the operator.\n         * 3) If this address is a contract (i.e. it has code) then we forward a call to the contract and verify that it returns the correct EIP-1271 \"magic value\".\n         */\n        address delegationApprover;\n        /**\n         * @notice A minimum delay -- measured in blocks -- enforced between:\n         * 1) the operator signalling their intent to register for a service, via calling `Slasher.optIntoSlashing`\n         * and\n         * 2) the operator completing registration for the service, via the service ultimately calling `Slasher.recordFirstStakeUpdate`\n         * @dev note that for a specific operator, this value *cannot decrease*, i.e. if the operator wishes to modify their OperatorDetails,\n         * then they are only allowed to either increase this value or keep it the same.\n         */\n        uint32 stakerOptOutWindowBlocks;\n    }\n\n    /**\n     * @notice Abstract struct used in calculating an EIP712 signature for a staker to approve that they (the staker themselves) delegate to a specific operator.\n     * @dev Used in computing the `STAKER_DELEGATION_TYPEHASH` and as a reference in the computation of the stakerDigestHash in the `delegateToBySignature` function.\n     */\n    struct StakerDelegation {\n        // the staker who is delegating\n        address staker;\n        // the operator being delegated to\n        address operator;\n        // the staker's nonce\n        uint256 nonce;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    /**\n     * @notice Abstract struct used in calculating an EIP712 signature for an operator's delegationApprover to approve that a specific staker delegate to the operator.\n     * @dev Used in computing the `DELEGATION_APPROVAL_TYPEHASH` and as a reference in the computation of the approverDigestHash in the `_delegate` function.\n     */\n    struct DelegationApproval {\n        // the staker who is delegating\n        address staker;\n        // the operator being delegated to\n        address operator;\n        // the operator's provided salt\n        bytes32 salt;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    /**\n     * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\n     * In functions that operate on existing queued withdrawals -- e.g. completeQueuedWithdrawal`, the data is resubmitted and the hash of the submitted\n     * data is computed by `calculateWithdrawalRoot` and checked against the stored hash in order to confirm the integrity of the submitted data.\n     */\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        IStrategy[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        IStrategy[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    // @notice Emitted when a new operator registers in EigenLayer and provides their OperatorDetails.\n    event OperatorRegistered(address indexed operator, OperatorDetails operatorDetails);\n\n    /// @notice Emitted when an operator updates their OperatorDetails to @param newOperatorDetails\n    event OperatorDetailsModified(address indexed operator, OperatorDetails newOperatorDetails);\n\n    /**\n     * @notice Emitted when @param operator indicates that they are updating their MetadataURI string\n     * @dev Note that these strings are *never stored in storage* and are instead purely emitted in events for off-chain indexing\n     */\n    event OperatorMetadataURIUpdated(address indexed operator, string metadataURI);\n\n    /// @notice Emitted whenever an operator's shares are increased for a given strategy. Note that shares is the delta in the operator's shares.\n    event OperatorSharesIncreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\n\n    /// @notice Emitted whenever an operator's shares are decreased for a given strategy. Note that shares is the delta in the operator's shares.\n    event OperatorSharesDecreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\n\n    /// @notice Emitted when @param staker delegates to @param operator.\n    event StakerDelegated(address indexed staker, address indexed operator);\n\n    /// @notice Emitted when @param staker undelegates from @param operator.\n    event StakerUndelegated(address indexed staker, address indexed operator);\n\n    /// @notice Emitted when @param staker is undelegated via a call not originating from the staker themself\n    event StakerForceUndelegated(address indexed staker, address indexed operator);\n\n    /**\n     * @notice Emitted when a new withdrawal is queued.\n     * @param withdrawalRoot Is the hash of the `withdrawal`.\n     * @param withdrawal Is the withdrawal itself.\n     */\n    event WithdrawalQueued(bytes32 withdrawalRoot, Withdrawal withdrawal);\n\n    /// @notice Emitted when a queued withdrawal is completed\n    event WithdrawalCompleted(bytes32 withdrawalRoot);\n\n    /// @notice Emitted when the `minWithdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\n    event MinWithdrawalDelayBlocksSet(uint256 previousValue, uint256 newValue);\n\n    /// @notice Emitted when the `strategyWithdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\n    event StrategyWithdrawalDelayBlocksSet(IStrategy strategy, uint256 previousValue, uint256 newValue);\n\n    /**\n     * @notice Registers the caller as an operator in EigenLayer.\n     * @param registeringOperatorDetails is the `OperatorDetails` for the operator.\n     * @param metadataURI is a URI for the operator's metadata, i.e. a link providing more details on the operator.\n     *\n     * @dev Once an operator is registered, they cannot 'deregister' as an operator, and they will forever be considered \"delegated to themself\".\n     * @dev This function will revert if the caller is already delegated to an operator.\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\n     */\n    function registerAsOperator(\n        OperatorDetails calldata registeringOperatorDetails,\n        string calldata metadataURI\n    ) external;\n\n    /**\n     * @notice Updates an operator's stored `OperatorDetails`.\n     * @param newOperatorDetails is the updated `OperatorDetails` for the operator, to replace their current OperatorDetails`.\n     *\n     * @dev The caller must have previously registered as an operator in EigenLayer.\n     */\n    function modifyOperatorDetails(OperatorDetails calldata newOperatorDetails) external;\n\n    /**\n     * @notice Called by an operator to emit an `OperatorMetadataURIUpdated` event indicating the information has updated.\n     * @param metadataURI The URI for metadata associated with an operator\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\n     */\n    function updateOperatorMetadataURI(string calldata metadataURI) external;\n\n    /**\n     * @notice Caller delegates their stake to an operator.\n     * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on EigenLayer.\n     * @param approverSignatureAndExpiry Verifies the operator approves of this delegation\n     * @param approverSalt A unique single use value tied to an individual signature.\n     * @dev The approverSignatureAndExpiry is used in the event that:\n     *          1) the operator's `delegationApprover` address is set to a non-zero value.\n     *                  AND\n     *          2) neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator\n     *             or their delegationApprover is the `msg.sender`, then approval is assumed.\n     * @dev In the event that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\n     * in this case to save on complexity + gas costs\n     */\n    function delegateTo(\n        address operator,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) external;\n\n    /**\n     * @notice Caller delegates a staker's stake to an operator with valid signatures from both parties.\n     * @param staker The account delegating stake to an `operator` account\n     * @param operator The account (`staker`) is delegating its assets to for use in serving applications built on EigenLayer.\n     * @param stakerSignatureAndExpiry Signed data from the staker authorizing delegating stake to an operator\n     * @param approverSignatureAndExpiry is a parameter that will be used for verifying that the operator approves of this delegation action in the event that:\n     * @param approverSalt Is a salt used to help guarantee signature uniqueness. Each salt can only be used once by a given approver.\n     *\n     * @dev If `staker` is an EOA, then `stakerSignature` is verified to be a valid ECDSA stakerSignature from `staker`, indicating their intention for this action.\n     * @dev If `staker` is a contract, then `stakerSignature` will be checked according to EIP-1271.\n     * @dev the operator's `delegationApprover` address is set to a non-zero value.\n     * @dev neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator or their delegationApprover\n     * is the `msg.sender`, then approval is assumed.\n     * @dev This function will revert if the current `block.timestamp` is equal to or exceeds the expiry\n     * @dev In the case that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\n     * in this case to save on complexity + gas costs\n     */\n    function delegateToBySignature(\n        address staker,\n        address operator,\n        SignatureWithExpiry memory stakerSignatureAndExpiry,\n        SignatureWithExpiry memory approverSignatureAndExpiry,\n        bytes32 approverSalt\n    ) external;\n\n    /**\n     * @notice Undelegates the staker from the operator who they are delegated to. Puts the staker into the \"undelegation limbo\" mode of the EigenPodManager\n     * and queues a withdrawal of all of the staker's shares in the StrategyManager (to the staker), if necessary.\n     * @param staker The account to be undelegated.\n     * @return withdrawalRoot The root of the newly queued withdrawal, if a withdrawal was queued. Otherwise just bytes32(0).\n     *\n     * @dev Reverts if the `staker` is also an operator, since operators are not allowed to undelegate from themselves.\n     * @dev Reverts if the caller is not the staker, nor the operator who the staker is delegated to, nor the operator's specified \"delegationApprover\"\n     * @dev Reverts if the `staker` is already undelegated.\n     */\n    function undelegate(address staker) external returns (bytes32[] memory withdrawalRoot);\n\n    /**\n     * Allows a staker to withdraw some shares. Withdrawn shares/strategies are immediately removed\n     * from the staker. If the staker is delegated, withdrawn shares/strategies are also removed from\n     * their operator.\n     *\n     * All withdrawn shares/strategies are placed in a queue and can be fully withdrawn after a delay.\n     */\n    function queueWithdrawals(QueuedWithdrawalParams[] calldata queuedWithdrawalParams)\n        external\n        returns (bytes32[] memory);\n\n    /**\n     * @notice Used to complete the specified `withdrawal`. The caller must match `withdrawal.withdrawer`\n     * @param withdrawal The Withdrawal to complete.\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\n     * This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\n     * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\n     * @param receiveAsTokens If true, the shares specified in the withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `withdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     * @dev middlewareTimesIndex is unused, but will be used in the Slasher eventually\n     * @dev beaconChainETHStrategy shares are non-transferrable, so if `receiveAsTokens = false` and `withdrawal.withdrawer != withdrawal.staker`, note that\n     * any beaconChainETHStrategy shares in the `withdrawal` will be _returned to the staker_, rather than transferred to the withdrawer, unlike shares in\n     * any other strategies, which will be transferred to the withdrawer.\n     */\n    function completeQueuedWithdrawal(\n        Withdrawal calldata withdrawal,\n        IERC20[] calldata tokens,\n        uint256 middlewareTimesIndex,\n        bool receiveAsTokens\n    ) external;\n\n    /**\n     * @notice Array-ified version of `completeQueuedWithdrawal`.\n     * Used to complete the specified `withdrawals`. The function caller must match `withdrawals[...].withdrawer`\n     * @param withdrawals The Withdrawals to complete.\n     * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\n     * @param middlewareTimesIndexes One index to reference per Withdrawal. See `completeQueuedWithdrawal` for the usage of a single index.\n     * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\n     * @dev See `completeQueuedWithdrawal` for relevant dev tags\n     */\n    function completeQueuedWithdrawals(\n        Withdrawal[] calldata withdrawals,\n        IERC20[][] calldata tokens,\n        uint256[] calldata middlewareTimesIndexes,\n        bool[] calldata receiveAsTokens\n    ) external;\n\n    /**\n     * @notice Increases a staker's delegated share balance in a strategy.\n     * @param staker The address to increase the delegated shares for their operator.\n     * @param strategy The strategy in which to increase the delegated shares.\n     * @param shares The number of shares to increase.\n     *\n     * @dev *If the staker is actively delegated*, then increases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\n     * @dev Callable only by the StrategyManager or EigenPodManager.\n     */\n    function increaseDelegatedShares(address staker, IStrategy strategy, uint256 shares) external;\n\n    /**\n     * @notice Decreases a staker's delegated share balance in a strategy.\n     * @param staker The address to increase the delegated shares for their operator.\n     * @param strategy The strategy in which to decrease the delegated shares.\n     * @param shares The number of shares to decrease.\n     *\n     * @dev *If the staker is actively delegated*, then decreases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\n     * @dev Callable only by the StrategyManager or EigenPodManager.\n     */\n    function decreaseDelegatedShares(address staker, IStrategy strategy, uint256 shares) external;\n\n    /**\n     * @notice Owner-only function for modifying the value of the `minWithdrawalDelayBlocks` variable.\n     * @param newMinWithdrawalDelayBlocks new value of `minWithdrawalDelayBlocks`.\n     */\n    function setMinWithdrawalDelayBlocks(uint256 newMinWithdrawalDelayBlocks) external; \n\n    /**\n     * @notice Called by owner to set the minimum withdrawal delay blocks for each passed in strategy\n     * Note that the min number of blocks to complete a withdrawal of a strategy is\n     * MAX(minWithdrawalDelayBlocks, strategyWithdrawalDelayBlocks[strategy])\n     * @param strategies The strategies to set the minimum withdrawal delay blocks for\n     * @param withdrawalDelayBlocks The minimum withdrawal delay blocks to set for each strategy\n     */\n    function setStrategyWithdrawalDelayBlocks(IStrategy[] calldata strategies, uint256[] calldata withdrawalDelayBlocks) external;\n\n    /**\n     * @notice returns the address of the operator that `staker` is delegated to.\n     * @notice Mapping: staker => operator whom the staker is currently delegated to.\n     * @dev Note that returning address(0) indicates that the staker is not actively delegated to any operator.\n     */\n    function delegatedTo(address staker) external view returns (address);\n\n    /**\n     * @notice Returns the OperatorDetails struct associated with an `operator`.\n     */\n    function operatorDetails(address operator) external view returns (OperatorDetails memory);\n\n    /**\n     * @notice Returns the delegationApprover account for an operator\n     */\n    function delegationApprover(address operator) external view returns (address);\n\n    /**\n     * @notice Returns the stakerOptOutWindowBlocks for an operator\n     */\n    function stakerOptOutWindowBlocks(address operator) external view returns (uint256);\n\n    /**\n     * @notice Given array of strategies, returns array of shares for the operator\n     */\n    function getOperatorShares(\n        address operator,\n        IStrategy[] memory strategies\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Given a list of strategies, return the minimum number of blocks that must pass to withdraw\n     * from all the inputted strategies. Return value is >= minWithdrawalDelayBlocks as this is the global min withdrawal delay.\n     * @param strategies The strategies to check withdrawal delays for\n     */\n    function getWithdrawalDelay(IStrategy[] calldata strategies) external view returns (uint256);\n\n    /**\n     * @notice returns the total number of shares in `strategy` that are delegated to `operator`.\n     * @notice Mapping: operator => strategy => total number of shares in the strategy delegated to the operator.\n     * @dev By design, the following invariant should hold for each Strategy:\n     * (operator's shares in delegation manager) = sum (shares above zero of all stakers delegated to operator)\n     * = sum (delegateable shares of all stakers delegated to the operator)\n     */\n    function operatorShares(address operator, IStrategy strategy) external view returns (uint256);\n\n\n    /**\n     * @notice Returns the number of actively-delegatable shares a staker has across all strategies.\n     * @dev Returns two empty arrays in the case that the Staker has no actively-delegateable shares.\n     */\n    function getDelegatableShares(address staker) external view returns (IStrategy[] memory, uint256[] memory);\n\n    /**\n     * @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n     */\n    function isDelegated(address staker) external view returns (bool);\n\n    /**\n     * @notice Returns true is an operator has previously registered for delegation.\n     */\n    function isOperator(address operator) external view returns (bool);\n\n    /// @notice Mapping: staker => number of signed delegation nonces (used in `delegateToBySignature`) from the staker that the contract has already checked\n    function stakerNonce(address staker) external view returns (uint256);\n\n    /**\n     * @notice Mapping: delegationApprover => 32-byte salt => whether or not the salt has already been used by the delegationApprover.\n     * @dev Salts are used in the `delegateTo` and `delegateToBySignature` functions. Note that these functions only process the delegationApprover's\n     * signature + the provided salt if the operator being delegated to has specified a nonzero address as their `delegationApprover`.\n     */\n    function delegationApproverSaltIsSpent(address _delegationApprover, bytes32 salt) external view returns (bool);\n\n    /**\n     * @notice Minimum delay enforced by this contract for completing queued withdrawals. Measured in blocks, and adjustable by this contract's owner,\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\n     * Note that strategies each have a separate withdrawal delay, which can be greater than this value. So the minimum number of blocks that must pass\n     * to withdraw a strategy is MAX(minWithdrawalDelayBlocks, strategyWithdrawalDelayBlocks[strategy])\n     */\n    function minWithdrawalDelayBlocks() external view returns (uint256);\n\n    /**\n     * @notice Minimum delay enforced by this contract per Strategy for completing queued withdrawals. Measured in blocks, and adjustable by this contract's owner,\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\n     */\n    function strategyWithdrawalDelayBlocks(IStrategy strategy) external view returns (uint256);\n\n    /// @notice return address of the beaconChainETHStrategy\n    function beaconChainETHStrategy() external view returns (IStrategy);\n\n    /**\n     * @notice Calculates the digestHash for a `staker` to sign to delegate to an `operator`\n     * @param staker The signing staker\n     * @param operator The operator who is being delegated to\n     * @param expiry The desired expiry time of the staker's signature\n     */\n    function calculateCurrentStakerDelegationDigestHash(\n        address staker,\n        address operator,\n        uint256 expiry\n    ) external view returns (bytes32);\n\n    /**\n     * @notice Calculates the digest hash to be signed and used in the `delegateToBySignature` function\n     * @param staker The signing staker\n     * @param _stakerNonce The nonce of the staker. In practice we use the staker's current nonce, stored at `stakerNonce[staker]`\n     * @param operator The operator who is being delegated to\n     * @param expiry The desired expiry time of the staker's signature\n     */\n    function calculateStakerDelegationDigestHash(\n        address staker,\n        uint256 _stakerNonce,\n        address operator,\n        uint256 expiry\n    ) external view returns (bytes32);\n\n    /**\n     * @notice Calculates the digest hash to be signed by the operator's delegationApprove and used in the `delegateTo` and `delegateToBySignature` functions.\n     * @param staker The account delegating their stake\n     * @param operator The account receiving delegated stake\n     * @param _delegationApprover the operator's `delegationApprover` who will be signing the delegationHash (in general)\n     * @param approverSalt A unique and single use value associated with the approver signature.\n     * @param expiry Time after which the approver's signature becomes invalid\n     */\n    function calculateDelegationApprovalDigestHash(\n        address staker,\n        address operator,\n        address _delegationApprover,\n        bytes32 approverSalt,\n        uint256 expiry\n    ) external view returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external view returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the StakerDelegation struct used by the contract\n    function STAKER_DELEGATION_TYPEHASH() external view returns (bytes32);\n\n    /// @notice The EIP-712 typehash for the DelegationApproval struct used by the contract\n    function DELEGATION_APPROVAL_TYPEHASH() external view returns (bytes32);\n\n    /**\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\n     *\n     * @dev The domain separator will change in the event of a fork that changes the ChainID.\n     * @dev By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.\n     * for more detailed information please read EIP-712.\n     */\n    function domainSeparator() external view returns (bytes32);\n\n    /// @notice Mapping: staker => cumulative number of queued withdrawals they have ever initiated.\n    /// @dev This only increments (doesn't decrement), and is used to help ensure that otherwise identical withdrawals have unique hashes.\n    function cumulativeWithdrawalsQueued(address staker) external view returns (uint256);\n\n    /// @notice Returns the keccak256 hash of `withdrawal`.\n    function calculateWithdrawalRoot(Withdrawal memory withdrawal) external pure returns (bytes32);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IEigenPod.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"./IEigenPodManager.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ninterface IEigenPod {\n    /**\n     *\n     *                                STRUCTS / ENUMS\n     *\n     */\n    enum VALIDATOR_STATUS {\n        INACTIVE, // doesnt exist\n        ACTIVE, // staked on ethpos and withdrawal credentials are pointed to the EigenPod\n        WITHDRAWN // withdrawn from the Beacon Chain\n\n    }\n\n    struct ValidatorInfo {\n        // index of the validator in the beacon chain\n        uint64 validatorIndex;\n        // amount of beacon chain ETH restaked on EigenLayer in gwei\n        uint64 restakedBalanceGwei;\n        //timestamp of the validator's most recent balance update\n        uint64 lastCheckpointedAt;\n        // status of the validator\n        VALIDATOR_STATUS status;\n    }\n\n    struct Checkpoint {\n        bytes32 beaconBlockRoot;\n        uint24 proofsRemaining;\n        uint64 podBalanceGwei;\n        int128 balanceDeltasGwei;\n    }\n\n    /**\n     *\n     *                                    EVENTS\n     *\n     */\n\n    /// @notice Emitted when an ETH validator stakes via this eigenPod\n    event EigenPodStaked(bytes pubkey);\n\n    /// @notice Emitted when a pod owner updates the proof submitter address\n    event ProofSubmitterUpdated(address prevProofSubmitter, address newProofSubmitter);\n\n    /// @notice Emitted when an ETH validator's withdrawal credentials are successfully verified to be pointed to this eigenPod\n    event ValidatorRestaked(uint40 validatorIndex);\n\n    /// @notice Emitted when an ETH validator's  balance is proven to be updated.  Here newValidatorBalanceGwei\n    //  is the validator's balance that is credited on EigenLayer.\n    event ValidatorBalanceUpdated(uint40 validatorIndex, uint64 balanceTimestamp, uint64 newValidatorBalanceGwei);\n\n    /// @notice Emitted when restaked beacon chain ETH is withdrawn from the eigenPod.\n    event RestakedBeaconChainETHWithdrawn(address indexed recipient, uint256 amount);\n\n    /// @notice Emitted when ETH is received via the `receive` fallback\n    event NonBeaconChainETHReceived(uint256 amountReceived);\n\n    /// @notice Emitted when a checkpoint is created\n    event CheckpointCreated(\n        uint64 indexed checkpointTimestamp, bytes32 indexed beaconBlockRoot, uint256 validatorCount\n    );\n\n    /// @notice Emitted when a checkpoint is finalized\n    event CheckpointFinalized(uint64 indexed checkpointTimestamp, int256 totalShareDeltaWei);\n\n    /// @notice Emitted when a validator is proven for a given checkpoint\n    event ValidatorCheckpointed(uint64 indexed checkpointTimestamp, uint40 indexed validatorIndex);\n\n    /// @notice Emitted when a validaor is proven to have 0 balance at a given checkpoint\n    event ValidatorWithdrawn(uint64 indexed checkpointTimestamp, uint40 indexed validatorIndex);\n\n    /**\n     *\n     *                       EXTERNAL STATE-CHANGING METHODS\n     *\n     */\n\n    /// @notice Used to initialize the pointers to contracts crucial to the pod's functionality, in beacon proxy construction from EigenPodManager\n    function initialize(address owner) external;\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev The podOwner must have already proved sufficient withdrawals, so that this pod's `withdrawableRestakedExecutionLayerGwei` exceeds the\n     * `amountWei` input (when converted to GWEI).\n     * @dev Reverts if `amountWei` is not a whole Gwei amount\n     */\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amount) external;\n\n    /**\n     * @dev Create a checkpoint used to prove this pod's active validator set. Checkpoints are completed\n     * by submitting one checkpoint proof per ACTIVE validator. During the checkpoint process, the total\n     * change in ACTIVE validator balance is tracked, and any validators with 0 balance are marked `WITHDRAWN`.\n     * @dev Once finalized, the pod owner is awarded shares corresponding to:\n     * - the total change in their ACTIVE validator balances\n     * - any ETH in the pod not already awarded shares\n     * @dev A checkpoint cannot be created if the pod already has an outstanding checkpoint. If\n     * this is the case, the pod owner MUST complete the existing checkpoint before starting a new one.\n     * @param revertIfNoBalance Forces a revert if the pod ETH balance is 0. This allows the pod owner\n     * to prevent accidentally starting a checkpoint that will not increase their shares\n     */\n    function startCheckpoint(bool revertIfNoBalance) external;\n\n    /**\n     * @dev Progress the current checkpoint towards completion by submitting one or more validator\n     * checkpoint proofs. Anyone can call this method to submit proofs towards the current checkpoint.\n     * For each validator proven, the current checkpoint's `proofsRemaining` decreases.\n     * @dev If the checkpoint's `proofsRemaining` reaches 0, the checkpoint is finalized.\n     * (see `_updateCheckpoint` for more details)\n     * @dev This method can only be called when there is a currently-active checkpoint.\n     * @param balanceContainerProof proves the beacon's current balance container root against a checkpoint's `beaconBlockRoot`\n     * @param proofs Proofs for one or more validator current balances against the `balanceContainerRoot`\n     */\n    function verifyCheckpointProofs(\n        BeaconChainProofs.BalanceContainerProof calldata balanceContainerProof,\n        BeaconChainProofs.BalanceProof[] calldata proofs\n    ) external;\n\n    /**\n     * @dev Verify one or more validators have their withdrawal credentials pointed at this EigenPod, and award\n     * shares based on their effective balance. Proven validators are marked `ACTIVE` within the EigenPod, and\n     * future checkpoint proofs will need to include them.\n     * @dev Withdrawal credential proofs MUST NOT be older than `currentCheckpointTimestamp`.\n     * @dev Validators proven via this method MUST NOT have an exit epoch set already.\n     * @param beaconTimestamp the beacon chain timestamp sent to the 4788 oracle contract. Corresponds\n     * to the parent beacon block root against which the proof is verified.\n     * @param stateRootProof proves a beacon state root against a beacon block root\n     * @param validatorIndices a list of validator indices being proven\n     * @param validatorFieldsProofs proofs of each validator's `validatorFields` against the beacon state root\n     * @param validatorFields the fields of the beacon chain \"Validator\" container. See consensus specs for\n     * details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentials(\n        uint64 beaconTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external;\n\n    /**\n     * @dev Prove that one of this pod's active validators was slashed on the beacon chain. A successful\n     * staleness proof allows the caller to start a checkpoint.\n     *\n     * @dev Note that in order to start a checkpoint, any existing checkpoint must already be completed!\n     * (See `_startCheckpoint` for details)\n     *\n     * @dev Note that this method allows anyone to start a checkpoint as soon as a slashing occurs on the beacon\n     * chain. This is intended to make it easier to external watchers to keep a pod's balance up to date.\n     *\n     * @dev Note too that beacon chain slashings are not instant. There is a delay between the initial slashing event\n     * and the validator's final exit back to the execution layer. During this time, the validator's balance may or\n     * may not drop further due to a correlation penalty. This method allows proof of a slashed validator\n     * to initiate a checkpoint for as long as the validator remains on the beacon chain. Once the validator\n     * has exited and been checkpointed at 0 balance, they are no longer \"checkpoint-able\" and cannot be proven\n     * \"stale\" via this method.\n     * See https://eth2book.info/capella/part3/transition/epoch/#slashings for more info.\n     *\n     * @param beaconTimestamp the beacon chain timestamp sent to the 4788 oracle contract. Corresponds\n     * to the parent beacon block root against which the proof is verified.\n     * @param stateRootProof proves a beacon state root against a beacon block root\n     * @param proof the fields of the beacon chain \"Validator\" container, along with a merkle proof against\n     * the beacon state root. See the consensus specs for more details:\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     *\n     * @dev Staleness conditions:\n     * - Validator's last checkpoint is older than `beaconTimestamp`\n     * - Validator MUST be in `ACTIVE` status in the pod\n     * - Validator MUST be slashed on the beacon chain\n     */\n    function verifyStaleBalance(\n        uint64 beaconTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        BeaconChainProofs.ValidatorProof calldata proof\n    ) external;\n\n    /// @notice called by owner of a pod to remove any ERC20s deposited in the pod\n    function recoverTokens(IERC20[] memory tokenList, uint256[] memory amountsToWithdraw, address recipient) external;\n\n    /// @notice Allows the owner of a pod to update the proof submitter, a permissioned\n    /// address that can call `startCheckpoint` and `verifyWithdrawalCredentials`.\n    /// @dev Note that EITHER the podOwner OR proofSubmitter can access these methods,\n    /// so it's fine to set your proofSubmitter to 0 if you want the podOwner to be the\n    /// only address that can call these methods.\n    /// @param newProofSubmitter The new proof submitter address. If set to 0, only the\n    /// pod owner will be able to call `startCheckpoint` and `verifyWithdrawalCredentials`\n    function setProofSubmitter(address newProofSubmitter) external;\n\n    /**\n     *\n     *                                VIEW METHODS\n     *\n     */\n\n    /// @notice An address with permissions to call `startCheckpoint` and `verifyWithdrawalCredentials`, set\n    /// by the podOwner. This role exists to allow a podOwner to designate a hot wallet that can call\n    /// these methods, allowing the podOwner to remain a cold wallet that is only used to manage funds.\n    /// @dev If this address is NOT set, only the podOwner can call `startCheckpoint` and `verifyWithdrawalCredentials`\n    function proofSubmitter() external view returns (address);\n\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from beaconchain but not EigenLayer),\n    function withdrawableRestakedExecutionLayerGwei() external view returns (uint64);\n\n    /// @notice The single EigenPodManager for EigenLayer\n    function eigenPodManager() external view returns (IEigenPodManager);\n\n    /// @notice The owner of this EigenPod\n    function podOwner() external view returns (address);\n\n    /// @notice Returns the validatorInfo struct for the provided pubkeyHash\n    function validatorPubkeyHashToInfo(bytes32 validatorPubkeyHash) external view returns (ValidatorInfo memory);\n\n    /// @notice Returns the validatorInfo struct for the provided pubkey\n    function validatorPubkeyToInfo(bytes calldata validatorPubkey) external view returns (ValidatorInfo memory);\n\n    /// @notice This returns the status of a given validator\n    function validatorStatus(bytes32 pubkeyHash) external view returns (VALIDATOR_STATUS);\n\n    /// @notice This returns the status of a given validator pubkey\n    function validatorStatus(bytes calldata validatorPubkey) external view returns (VALIDATOR_STATUS);\n\n    /// @notice Number of validators with proven withdrawal credentials, who do not have proven full withdrawals\n    function activeValidatorCount() external view returns (uint256);\n\n    /// @notice The timestamp of the last checkpoint finalized\n    function lastCheckpointTimestamp() external view returns (uint64);\n\n    /// @notice The timestamp of the currently-active checkpoint. Will be 0 if there is not active checkpoint\n    function currentCheckpointTimestamp() external view returns (uint64);\n\n    /// @notice Returns the currently-active checkpoint\n    function currentCheckpoint() external view returns (Checkpoint memory);\n\n    /// @notice For each checkpoint, the total balance attributed to exited validators, in gwei\n    ///\n    /// NOTE that the values added to this mapping are NOT guaranteed to capture the entirety of a validator's\n    /// exit - rather, they capture the total change in a validator's balance when a checkpoint shows their\n    /// balance change from nonzero to zero. While a change from nonzero to zero DOES guarantee that a validator\n    /// has been fully exited, it is possible that the magnitude of this change does not capture what is\n    /// typically thought of as a \"full exit.\"\n    ///\n    /// For example:\n    /// 1. Consider a validator was last checkpointed at 32 ETH before exiting. Once the exit has been processed,\n    /// it is expected that the validator's exited balance is calculated to be `32 ETH`.\n    /// 2. However, before `startCheckpoint` is called, a deposit is made to the validator for 1 ETH. The beacon\n    /// chain will automatically withdraw this ETH, but not until the withdrawal sweep passes over the validator\n    /// again. Until this occurs, the validator's current balance (used for checkpointing) is 1 ETH.\n    /// 3. If `startCheckpoint` is called at this point, the balance delta calculated for this validator will be\n    /// `-31 ETH`, and because the validator has a nonzero balance, it is not marked WITHDRAWN.\n    /// 4. After the exit is processed by the beacon chain, a subsequent `startCheckpoint` and checkpoint proof\n    /// will calculate a balance delta of `-1 ETH` and attribute a 1 ETH exit to the validator.\n    ///\n    /// If this edge case impacts your usecase, it should be possible to mitigate this by monitoring for deposits\n    /// to your exited validators, and waiting to call `startCheckpoint` until those deposits have been automatically\n    /// exited.\n    ///\n    /// Additional edge cases this mapping does not cover:\n    /// - If a validator is slashed, their balance exited will reflect their original balance rather than the slashed amount\n    /// - The final partial withdrawal for an exited validator will be likely be included in this mapping.\n    ///   i.e. if a validator was last checkpointed at 32.1 ETH before exiting, the next checkpoint will calculate their\n    ///   \"exited\" amount to be 32.1 ETH rather than 32 ETH.\n    function checkpointBalanceExitedGwei(uint64) external view returns (uint64);\n\n    /// @notice Query the 4788 oracle to get the parent block root of the slot with the given `timestamp`\n    /// @param timestamp of the block for which the parent block root will be returned. MUST correspond\n    /// to an existing slot within the last 24 hours. If the slot at `timestamp` was skipped, this method\n    /// will revert.\n    function getParentBlockRoot(uint64 timestamp) external view returns (bytes32);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IEigenPodManager.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"./IETHPOSDeposit.sol\";\nimport \"./IStrategyManager.sol\";\nimport \"./IEigenPod.sol\";\nimport \"./IPausable.sol\";\nimport \"./ISlasher.sol\";\nimport \"./IStrategy.sol\";\n\n/**\n * @title Interface for factory that creates and manages solo staking pods that have their withdrawal credentials pointed to EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IEigenPodManager is IPausable {\n    /// @notice Emitted to notify the deployment of an EigenPod\n    event PodDeployed(address indexed eigenPod, address indexed podOwner);\n\n    /// @notice Emitted to notify a deposit of beacon chain ETH recorded in the strategy manager\n    event BeaconChainETHDeposited(address indexed podOwner, uint256 amount);\n\n    /// @notice Emitted when the balance of an EigenPod is updated\n    event PodSharesUpdated(address indexed podOwner, int256 sharesDelta);\n\n    /// @notice Emitted every time the total shares of a pod are updated\n    event NewTotalShares(address indexed podOwner, int256 newTotalShares);\n\n    /// @notice Emitted when a withdrawal of beacon chain ETH is completed\n    event BeaconChainETHWithdrawalCompleted(\n        address indexed podOwner,\n        uint256 shares,\n        uint96 nonce,\n        address delegatedAddress,\n        address withdrawer,\n        bytes32 withdrawalRoot\n    );\n\n    /**\n     * @notice Creates an EigenPod for the sender.\n     * @dev Function will revert if the `msg.sender` already has an EigenPod.\n     * @dev Returns EigenPod address\n     */\n    function createPod() external returns (address);\n\n    /**\n     * @notice Stakes for a new beacon chain validator on the sender's EigenPod.\n     * Also creates an EigenPod for the sender if they don't have one already.\n     * @param pubkey The 48 bytes public key of the beacon chain validator.\n     * @param signature The validator's signature of the deposit data.\n     * @param depositDataRoot The root/hash of the deposit data for the validator's deposit.\n     */\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n\n    /**\n     * @notice Changes the `podOwner`'s shares by `sharesDelta` and performs a call to the DelegationManager\n     * to ensure that delegated shares are also tracked correctly\n     * @param podOwner is the pod owner whose balance is being updated.\n     * @param sharesDelta is the change in podOwner's beaconChainETHStrategy shares\n     * @dev Callable only by the podOwner's EigenPod contract.\n     * @dev Reverts if `sharesDelta` is not a whole Gwei amount\n     */\n    function recordBeaconChainETHBalanceUpdate(address podOwner, int256 sharesDelta) external;\n\n    /// @notice Returns the address of the `podOwner`'s EigenPod if it has been deployed.\n    function ownerToPod(address podOwner) external view returns (IEigenPod);\n\n    /// @notice Returns the address of the `podOwner`'s EigenPod (whether it is deployed yet or not).\n    function getPod(address podOwner) external view returns (IEigenPod);\n\n    /// @notice The ETH2 Deposit Contract\n    function ethPOS() external view returns (IETHPOSDeposit);\n\n    /// @notice Beacon proxy to which the EigenPods point\n    function eigenPodBeacon() external view returns (IBeacon);\n\n    /// @notice EigenLayer's StrategyManager contract\n    function strategyManager() external view returns (IStrategyManager);\n\n    /// @notice EigenLayer's Slasher contract\n    function slasher() external view returns (ISlasher);\n\n    /// @notice Returns 'true' if the `podOwner` has created an EigenPod, and 'false' otherwise.\n    function hasPod(address podOwner) external view returns (bool);\n\n    /// @notice Returns the number of EigenPods that have been created\n    function numPods() external view returns (uint256);\n\n    /**\n     * @notice Mapping from Pod owner owner to the number of shares they have in the virtual beacon chain ETH strategy.\n     * @dev The share amount can become negative. This is necessary to accommodate the fact that a pod owner's virtual beacon chain ETH shares can\n     * decrease between the pod owner queuing and completing a withdrawal.\n     * When the pod owner's shares would otherwise increase, this \"deficit\" is decreased first _instead_.\n     * Likewise, when a withdrawal is completed, this \"deficit\" is decreased and the withdrawal amount is decreased; We can think of this\n     * as the withdrawal \"paying off the deficit\".\n     */\n    function podOwnerShares(address podOwner) external view returns (int256);\n\n    /// @notice returns canonical, virtual beaconChainETH strategy\n    function beaconChainETHStrategy() external view returns (IStrategy);\n\n    /**\n     * @notice Used by the DelegationManager to remove a pod owner's shares while they're in the withdrawal queue.\n     * Simply decreases the `podOwner`'s shares by `shares`, down to a minimum of zero.\n     * @dev This function reverts if it would result in `podOwnerShares[podOwner]` being less than zero, i.e. it is forbidden for this function to\n     * result in the `podOwner` incurring a \"share deficit\". This behavior prevents a Staker from queuing a withdrawal which improperly removes excessive\n     * shares from the operator to whom the staker is delegated.\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     */\n    function removeShares(address podOwner, uint256 shares) external;\n\n    /**\n     * @notice Increases the `podOwner`'s shares by `shares`, paying off deficit if possible.\n     * Used by the DelegationManager to award a pod owner shares on exiting the withdrawal queue\n     * @dev Returns the number of shares added to `podOwnerShares[podOwner]` above zero, which will be less than the `shares` input\n     * in the event that the podOwner has an existing shares deficit (i.e. `podOwnerShares[podOwner]` starts below zero)\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     */\n    function addShares(address podOwner, uint256 shares) external returns (uint256);\n\n    /**\n     * @notice Used by the DelegationManager to complete a withdrawal, sending tokens to some destination address\n     * @dev Prioritizes decreasing the podOwner's share deficit, if they have one\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     */\n    function withdrawSharesAsTokens(address podOwner, address destination, uint256 shares) external;\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IETHPOSDeposit.sol": {
        "content": "// \n// \n// \n// \n// \n// \n// \n// \n\n// SPDX-License-Identifier: CC0-1.0\n\npragma solidity >=0.5.0;\n\n// This interface is designed to be compatible with the Vyper version.\n/// @notice This is the Ethereum 2.0 deposit contract interface.\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\ninterface IETHPOSDeposit {\n    /// @notice A processed deposit event.\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IPausable.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"../interfaces/IPauserRegistry.sol\";\n\n/**\n * @title Adds pausability to a contract, with pausing & unpausing controlled by the `pauser` and `unpauser` of a PauserRegistry contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Contracts that inherit from this contract may define their own `pause` and `unpause` (and/or related) functions.\n * These functions should be permissioned as \"onlyPauser\" which defers to a `PauserRegistry` for determining access control.\n * @dev Pausability is implemented using a uint256, which allows up to 256 different single bit-flags; each bit can potentially pause different functionality.\n * Inspiration for this was taken from the NearBridge design here https://etherscan.io/address/0x3FEFc5A4B1c02f21cBc8D3613643ba0635b9a873#code.\n * For the `pause` and `unpause` functions we've implemented, if you pause, you can only flip (any number of) switches to on/1 (aka \"paused\"), and if you unpause,\n * you can only flip (any number of) switches to off/0 (aka \"paused\").\n * If you want a pauseXYZ function that just flips a single bit / \"pausing flag\", it will:\n * 1) 'bit-wise and' (aka `&`) a flag with the current paused state (as a uint256)\n * 2) update the paused state to this new value\n * @dev We note as well that we have chosen to identify flags by their *bit index* as opposed to their numerical value, so, e.g. defining `DEPOSITS_PAUSED = 3`\n * indicates specifically that if the *third bit* of `_paused` is flipped -- i.e. it is a '1' -- then deposits should be paused\n */\ninterface IPausable {\n    /// @notice Emitted when the `pauserRegistry` is set to `newPauserRegistry`.\n    event PauserRegistrySet(IPauserRegistry pauserRegistry, IPauserRegistry newPauserRegistry);\n\n    /// @notice Emitted when the pause is triggered by `account`, and changed to `newPausedStatus`.\n    event Paused(address indexed account, uint256 newPausedStatus);\n\n    /// @notice Emitted when the pause is lifted by `account`, and changed to `newPausedStatus`.\n    event Unpaused(address indexed account, uint256 newPausedStatus);\n\n    /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\n    function pauserRegistry() external view returns (IPauserRegistry);\n\n    /**\n     * @notice This function is used to pause an EigenLayer contract's functionality.\n     * It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\n     * @dev This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\n     */\n    function pause(uint256 newPausedStatus) external;\n\n    /**\n     * @notice Alias for `pause(type(uint256).max)`.\n     */\n    function pauseAll() external;\n\n    /**\n     * @notice This function is used to unpause an EigenLayer contract's functionality.\n     * It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\n     * @dev This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\n     */\n    function unpause(uint256 newPausedStatus) external;\n\n    /// @notice Returns the current paused status as a uint256.\n    function paused() external view returns (uint256);\n\n    /// @notice Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\n    function paused(uint8 index) external view returns (bool);\n\n    /// @notice Allows the unpauser to set a new pauser registry\n    function setPauserRegistry(IPauserRegistry newPauserRegistry) external;\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IPauserRegistry.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/**\n * @title Interface for the `PauserRegistry` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IPauserRegistry {\n    event PauserStatusChanged(address pauser, bool canPause);\n\n    event UnpauserChanged(address previousUnpauser, address newUnpauser);\n\n    /// @notice Mapping of addresses to whether they hold the pauser role.\n    function isPauser(address pauser) external view returns (bool);\n\n    /// @notice Unique address that holds the unpauser role. Capable of changing *both* the pauser and unpauser addresses.\n    function unpauser() external view returns (address);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IRewardsCoordinator.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IStrategy.sol\";\n\n/**\n * @title Interface for the `IRewardsCoordinator` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Allows AVSs to make \"Rewards Submissions\", which get distributed amongst the AVSs' confirmed\n * Operators and the Stakers delegated to those Operators.\n * Calculations are performed based on the completed RewardsSubmission, with the results posted in\n * a Merkle root against which Stakers & Operators can make claims.\n */\ninterface IRewardsCoordinator {\n    /// STRUCTS ///\n    /**\n     * @notice A linear combination of strategies and multipliers for AVSs to weigh\n     * EigenLayer strategies.\n     * @param strategy The EigenLayer strategy to be used for the rewards submission\n     * @param multiplier The weight of the strategy in the rewards submission\n     */\n    struct StrategyAndMultiplier {\n        IStrategy strategy;\n        uint96 multiplier;\n    }\n\n    /**\n     * @notice A reward struct for an operator\n     * @param operator The operator to be rewarded\n     * @param amount The reward amount for the operator\n     */\n    struct OperatorReward {\n        address operator;\n        uint256 amount;\n    }\n\n    /**\n     * @notice A split struct for an Operator\n     * @param oldSplitBips The old split in basis points. This is the split that is active if `block.timestamp < activatedAt`\n     * @param newSplitBips The new split in basis points. This is the split that is active if `block.timestamp >= activatedAt`\n     * @param activatedAt The timestamp at which the split will be activated\n     */\n    struct OperatorSplit {\n        uint16 oldSplitBips;\n        uint16 newSplitBips;\n        uint32 activatedAt;\n    }\n\n    /**\n     * Sliding Window for valid RewardsSubmission startTimestamp\n     *\n     * Scenario A: GENESIS_REWARDS_TIMESTAMP IS WITHIN RANGE\n     *         <-----MAX_RETROACTIVE_LENGTH-----> t (block.timestamp) <---MAX_FUTURE_LENGTH--->\n     *             <--------------------valid range for startTimestamp------------------------>\n     *             ^\n     *         GENESIS_REWARDS_TIMESTAMP\n     *\n     *\n     * Scenario B: GENESIS_REWARDS_TIMESTAMP IS OUT OF RANGE\n     *         <-----MAX_RETROACTIVE_LENGTH-----> t (block.timestamp) <---MAX_FUTURE_LENGTH--->\n     *         <------------------------valid range for startTimestamp------------------------>\n     *     ^\n     * GENESIS_REWARDS_TIMESTAMP\n     * @notice RewardsSubmission struct submitted by AVSs when making rewards for their operators and stakers\n     * RewardsSubmission can be for a time range within the valid window for startTimestamp and must be within max duration.\n     * See `createAVSRewardsSubmission()` for more details.\n     * @param strategiesAndMultipliers The strategies and their relative weights\n     * cannot have duplicate strategies and need to be sorted in ascending address order\n     * @param token The rewards token to be distributed\n     * @param amount The total amount of tokens to be distributed\n     * @param startTimestamp The timestamp (seconds) at which the submission range is considered for distribution\n     * could start in the past or in the future but within a valid range. See the diagram above.\n     * @param duration The duration of the submission range in seconds. Must be <= MAX_REWARDS_DURATION\n     */\n    struct RewardsSubmission {\n        StrategyAndMultiplier[] strategiesAndMultipliers;\n        IERC20 token;\n        uint256 amount;\n        uint32 startTimestamp;\n        uint32 duration;\n    }\n\n    /**\n     * @notice OperatorDirectedRewardsSubmission struct submitted by AVSs when making operator-directed rewards for their operators and stakers.\n     * @param strategiesAndMultipliers The strategies and their relative weights.\n     * @param token The rewards token to be distributed.\n     * @param operatorRewards The rewards for the operators.\n     * @param startTimestamp The timestamp (seconds) at which the submission range is considered for distribution.\n     * @param duration The duration of the submission range in seconds.\n     * @param description Describes what the rewards submission is for.\n     */\n    struct OperatorDirectedRewardsSubmission {\n        StrategyAndMultiplier[] strategiesAndMultipliers;\n        IERC20 token;\n        OperatorReward[] operatorRewards;\n        uint32 startTimestamp;\n        uint32 duration;\n        string description;\n    }\n\n    /**\n     * @notice A distribution root is a merkle root of the distribution of earnings for a given period.\n     * The RewardsCoordinator stores all historical distribution roots so that earners can claim their earnings against older roots\n     * if they wish but the merkle tree contains the cumulative earnings of all earners and tokens for a given period so earners (or their claimers if set)\n     * only need to claim against the latest root to claim all available earnings.\n     * @param root The merkle root of the distribution\n     * @param rewardsCalculationEndTimestamp The timestamp (seconds) until which rewards have been calculated\n     * @param activatedAt The timestamp (seconds) at which the root can be claimed against\n     */\n    struct DistributionRoot {\n        bytes32 root;\n        uint32 rewardsCalculationEndTimestamp;\n        uint32 activatedAt;\n        bool disabled;\n    }\n\n    /**\n     * @notice Internal leaf in the merkle tree for the earner's account leaf\n     * @param earner The address of the earner\n     * @param earnerTokenRoot The merkle root of the earner's token subtree\n     * Each leaf in the earner's token subtree is a TokenTreeMerkleLeaf\n     */\n    struct EarnerTreeMerkleLeaf {\n        address earner;\n        bytes32 earnerTokenRoot;\n    }\n\n    /**\n     * @notice The actual leaves in the distribution merkle tree specifying the token earnings\n     * for the respective earner's subtree. Each leaf is a claimable amount of a token for an earner.\n     * @param token The token for which the earnings are being claimed\n     * @param cumulativeEarnings The cumulative earnings of the earner for the token\n     */\n    struct TokenTreeMerkleLeaf {\n        IERC20 token;\n        uint256 cumulativeEarnings;\n    }\n\n    /**\n     * @notice A claim against a distribution root called by an\n     * earners claimer (could be the earner themselves). Each token claim will claim the difference\n     * between the cumulativeEarnings of the earner and the cumulativeClaimed of the claimer.\n     * Each claim can specify which of the earner's earned tokens they want to claim.\n     * See `processClaim()` for more details.\n     * @param rootIndex The index of the root in the list of DistributionRoots\n     * @param earnerIndex The index of the earner's account root in the merkle tree\n     * @param earnerTreeProof The proof of the earner's EarnerTreeMerkleLeaf against the merkle root\n     * @param earnerLeaf The earner's EarnerTreeMerkleLeaf struct, providing the earner address and earnerTokenRoot\n     * @param tokenIndices The indices of the token leaves in the earner's subtree\n     * @param tokenTreeProofs The proofs of the token leaves against the earner's earnerTokenRoot\n     * @param tokenLeaves The token leaves to be claimed\n     * @dev The merkle tree is structured with the merkle root at the top and EarnerTreeMerkleLeaf as internal leaves\n     * in the tree. Each earner leaf has its own subtree with TokenTreeMerkleLeaf as leaves in the subtree.\n     * To prove a claim against a specified rootIndex(which specifies the distributionRoot being used),\n     * the claim will first verify inclusion of the earner leaf in the tree against _distributionRoots[rootIndex].root.\n     * Then for each token, it will verify inclusion of the token leaf in the earner's subtree against the earner's earnerTokenRoot.\n     */\n    struct RewardsMerkleClaim {\n        uint32 rootIndex;\n        uint32 earnerIndex;\n        bytes earnerTreeProof;\n        EarnerTreeMerkleLeaf earnerLeaf;\n        uint32[] tokenIndices;\n        bytes[] tokenTreeProofs;\n        TokenTreeMerkleLeaf[] tokenLeaves;\n    }\n\n    /// EVENTS ///\n\n    /// @notice emitted when an AVS creates a valid RewardsSubmission\n    event AVSRewardsSubmissionCreated(\n        address indexed avs,\n        uint256 indexed submissionNonce,\n        bytes32 indexed rewardsSubmissionHash,\n        RewardsSubmission rewardsSubmission\n    );\n    /// @notice emitted when a valid RewardsSubmission is created for all stakers by a valid submitter\n    event RewardsSubmissionForAllCreated(\n        address indexed submitter,\n        uint256 indexed submissionNonce,\n        bytes32 indexed rewardsSubmissionHash,\n        RewardsSubmission rewardsSubmission\n    );\n    /// @notice emitted when a valid RewardsSubmission is created when rewardAllStakersAndOperators is called\n    event RewardsSubmissionForAllEarnersCreated(\n        address indexed tokenHopper,\n        uint256 indexed submissionNonce,\n        bytes32 indexed rewardsSubmissionHash,\n        RewardsSubmission rewardsSubmission\n    );\n\n    /**\n     * @notice Emitted when an AVS creates a valid `OperatorDirectedRewardsSubmission`\n     * @param caller The address calling `createOperatorDirectedAVSRewardsSubmission`.\n     * @param avs The avs on behalf of which the operator-directed rewards are being submitted.\n     * @param operatorDirectedRewardsSubmissionHash Keccak256 hash of (`avs`, `submissionNonce` and `operatorDirectedRewardsSubmission`).\n     * @param submissionNonce Current nonce of the avs. Used to generate a unique submission hash.\n     * @param operatorDirectedRewardsSubmission The Operator-Directed Rewards Submission. Contains the token, start timestamp, duration, operator rewards, description and, strategy and multipliers.\n     */\n    event OperatorDirectedAVSRewardsSubmissionCreated(\n        address indexed caller,\n        address indexed avs,\n        bytes32 indexed operatorDirectedRewardsSubmissionHash,\n        uint256 submissionNonce,\n        OperatorDirectedRewardsSubmission operatorDirectedRewardsSubmission\n    );\n\n    /// @notice rewardsUpdater is responsible for submiting DistributionRoots, only owner can set rewardsUpdater\n    event RewardsUpdaterSet(address indexed oldRewardsUpdater, address indexed newRewardsUpdater);\n    event RewardsForAllSubmitterSet(\n        address indexed rewardsForAllSubmitter,\n        bool indexed oldValue,\n        bool indexed newValue\n    );\n    event ActivationDelaySet(uint32 oldActivationDelay, uint32 newActivationDelay);\n    event DefaultOperatorSplitBipsSet(uint16 oldDefaultOperatorSplitBips, uint16 newDefaultOperatorSplitBips);\n\n    /**\n     * @notice Emitted when the operator split for an AVS is set.\n     * @param caller The address calling `setOperatorAVSSplit`.\n     * @param operator The operator on behalf of which the split is being set.\n     * @param avs The avs for which the split is being set by the operator.\n     * @param activatedAt The timestamp at which the split will be activated.\n     * @param oldOperatorAVSSplitBips The old split for the operator for the AVS.\n     * @param newOperatorAVSSplitBips The new split for the operator for the AVS.\n     */\n    event OperatorAVSSplitBipsSet(\n        address indexed caller,\n        address indexed operator,\n        address indexed avs,\n        uint32 activatedAt,\n        uint16 oldOperatorAVSSplitBips,\n        uint16 newOperatorAVSSplitBips\n    );\n\n    /**\n     * @notice Emitted when the operator split for Programmatic Incentives is set.\n     * @param caller The address calling `setOperatorPISplit`.\n     * @param operator The operator on behalf of which the split is being set.\n     * @param activatedAt The timestamp at which the split will be activated.\n     * @param oldOperatorPISplitBips The old split for the operator for Programmatic Incentives.\n     * @param newOperatorPISplitBips The new split for the operator for Programmatic Incentives.\n     */\n    event OperatorPISplitBipsSet(\n        address indexed caller,\n        address indexed operator,\n        uint32 activatedAt,\n        uint16 oldOperatorPISplitBips,\n        uint16 newOperatorPISplitBips\n    );\n\n    event ClaimerForSet(address indexed earner, address indexed oldClaimer, address indexed claimer);\n    /// @notice rootIndex is the specific array index of the newly created root in the storage array\n    event DistributionRootSubmitted(\n        uint32 indexed rootIndex,\n        bytes32 indexed root,\n        uint32 indexed rewardsCalculationEndTimestamp,\n        uint32 activatedAt\n    );\n    event DistributionRootDisabled(uint32 indexed rootIndex);\n    /// @notice root is one of the submitted distribution roots that was claimed against\n    event RewardsClaimed(\n        bytes32 root,\n        address indexed earner,\n        address indexed claimer,\n        address indexed recipient,\n        IERC20 token,\n        uint256 claimedAmount\n    );\n\n    /**\n     *\n     *                         VIEW FUNCTIONS\n     *\n     */\n\n    /// @notice The address of the entity that can update the contract with new merkle roots\n    function rewardsUpdater() external view returns (address);\n\n    /**\n     * @notice The interval in seconds at which the calculation for a RewardsSubmission distribution is done.\n     * @dev Rewards Submission durations must be multiples of this interval.\n     */\n    function CALCULATION_INTERVAL_SECONDS() external view returns (uint32);\n\n    /// @notice The maximum amount of time (seconds) that a RewardsSubmission can span over\n    function MAX_REWARDS_DURATION() external view returns (uint32);\n\n    /// @notice max amount of time (seconds) that a submission can start in the past\n    function MAX_RETROACTIVE_LENGTH() external view returns (uint32);\n\n    /// @notice max amount of time (seconds) that a submission can start in the future\n    function MAX_FUTURE_LENGTH() external view returns (uint32);\n\n    /// @notice absolute min timestamp (seconds) that a submission can start at\n    function GENESIS_REWARDS_TIMESTAMP() external view returns (uint32);\n\n    /// @notice Delay in timestamp (seconds) before a posted root can be claimed against\n    function activationDelay() external view returns (uint32);\n\n    /// @notice Mapping: earner => the address of the entity who can call `processClaim` on behalf of the earner\n    function claimerFor(address earner) external view returns (address);\n\n    /// @notice Mapping: claimer => token => total amount claimed\n    function cumulativeClaimed(address claimer, IERC20 token) external view returns (uint256);\n\n    /// @notice the defautl split for all operators across all avss\n    function defaultOperatorSplitBips() external view returns (uint16);\n\n    /// @notice the split for a specific `operator` for a specific `avs`\n    function getOperatorAVSSplit(address operator, address avs) external view returns (uint16);\n\n    /// @notice the split for a specific `operator` for Programmatic Incentives\n    function getOperatorPISplit(address operator) external view returns (uint16);\n\n    /// @notice return the hash of the earner's leaf\n    function calculateEarnerLeafHash(EarnerTreeMerkleLeaf calldata leaf) external pure returns (bytes32);\n\n    /// @notice returns the hash of the earner's token leaf\n    function calculateTokenLeafHash(TokenTreeMerkleLeaf calldata leaf) external pure returns (bytes32);\n\n    /// @notice returns 'true' if the claim would currently pass the check in `processClaims`\n    /// but will revert if not valid\n    function checkClaim(RewardsMerkleClaim calldata claim) external view returns (bool);\n\n    /// @notice The timestamp until which RewardsSubmissions have been calculated\n    function currRewardsCalculationEndTimestamp() external view returns (uint32);\n\n    /// @notice returns the number of distribution roots posted\n    function getDistributionRootsLength() external view returns (uint256);\n\n    /// @notice returns the distributionRoot at the specified index\n    function getDistributionRootAtIndex(uint256 index) external view returns (DistributionRoot memory);\n\n    /// @notice returns the current distributionRoot\n    function getCurrentDistributionRoot() external view returns (DistributionRoot memory);\n\n    /// @notice loop through the distribution roots from reverse and get latest root that is not disabled and activated\n    /// i.e. a root that can be claimed against\n    function getCurrentClaimableDistributionRoot() external view returns (DistributionRoot memory);\n\n    /// @notice loop through distribution roots from reverse and return index from hash\n    function getRootIndexFromHash(bytes32 rootHash) external view returns (uint32);\n\n    /**\n     *\n     *                         EXTERNAL FUNCTIONS\n     *\n     */\n\n    /**\n     * @notice Creates a new rewards submission on behalf of an AVS, to be split amongst the\n     * set of stakers delegated to operators who are registered to the `avs`\n     * @param rewardsSubmissions The rewards submissions being created\n     * @dev Expected to be called by the ServiceManager of the AVS on behalf of which the submission is being made\n     * @dev The duration of the `rewardsSubmission` cannot exceed `MAX_REWARDS_DURATION`\n     * @dev The tokens are sent to the `RewardsCoordinator` contract\n     * @dev Strategies must be in ascending order of addresses to check for duplicates\n     * @dev This function will revert if the `rewardsSubmission` is malformed,\n     * e.g. if the `strategies` and `weights` arrays are of non-equal lengths\n     */\n    function createAVSRewardsSubmission(RewardsSubmission[] calldata rewardsSubmissions) external;\n\n    /**\n     * @notice similar to `createAVSRewardsSubmission` except the rewards are split amongst *all* stakers\n     * rather than just those delegated to operators who are registered to a single avs and is\n     * a permissioned call based on isRewardsForAllSubmitter mapping.\n     * @param rewardsSubmission The rewards submission being created\n     */\n    function createRewardsForAllSubmission(RewardsSubmission[] calldata rewardsSubmission) external;\n\n    /**\n     * @notice Creates a new rewards submission for all earners across all AVSs.\n     * Earners in this case indicating all operators and their delegated stakers. Undelegated stake\n     * is not rewarded from this RewardsSubmission. This interface is only callable\n     * by the token hopper contract from the Eigen Foundation\n     * @param rewardsSubmissions The rewards submissions being created\n     */\n    function createRewardsForAllEarners(RewardsSubmission[] calldata rewardsSubmissions) external;\n\n    /**\n     * @notice Creates a new operator-directed rewards submission on behalf of an AVS, to be split amongst the operators and\n     * set of stakers delegated to operators who are registered to the `avs`.\n     * @param avs The AVS on behalf of which the reward is being submitted\n     * @param operatorDirectedRewardsSubmissions The operator-directed rewards submissions being created\n     * @dev Expected to be called by the ServiceManager of the AVS on behalf of which the submission is being made\n     * @dev The duration of the `rewardsSubmission` cannot exceed `MAX_REWARDS_DURATION`\n     * @dev The tokens are sent to the `RewardsCoordinator` contract\n     * @dev The `RewardsCoordinator` contract needs a token approval of sum of all `operatorRewards` in the `operatorDirectedRewardsSubmissions`, before calling this function.\n     * @dev Strategies must be in ascending order of addresses to check for duplicates\n     * @dev Operators must be in ascending order of addresses to check for duplicates.\n     * @dev This function will revert if the `operatorDirectedRewardsSubmissions` is malformed.\n     */\n    function createOperatorDirectedAVSRewardsSubmission(\n        address avs,\n        OperatorDirectedRewardsSubmission[] calldata operatorDirectedRewardsSubmissions\n    ) external;\n\n    /**\n     * @notice Claim rewards against a given root (read from _distributionRoots[claim.rootIndex]).\n     * Earnings are cumulative so earners don't have to claim against all distribution roots they have earnings for,\n     * they can simply claim against the latest root and the contract will calculate the difference between\n     * their cumulativeEarnings and cumulativeClaimed. This difference is then transferred to recipient address.\n     * @param claim The RewardsMerkleClaim to be processed.\n     * Contains the root index, earner, token leaves, and required proofs\n     * @param recipient The address recipient that receives the ERC20 rewards\n     * @dev only callable by the valid claimer, that is\n     * if claimerFor[claim.earner] is address(0) then only the earner can claim, otherwise only\n     * claimerFor[claim.earner] can claim the rewards.\n     */\n    function processClaim(RewardsMerkleClaim calldata claim, address recipient) external;\n\n    /**\n     * @notice Batch claim rewards against a given root (read from _distributionRoots[claim.rootIndex]).\n     * Earnings are cumulative so earners don't have to claim against all distribution roots they have earnings for,\n     * they can simply claim against the latest root and the contract will calculate the difference between\n     * their cumulativeEarnings and cumulativeClaimed. This difference is then transferred to recipient address.\n     * @param claims The RewardsMerkleClaims to be processed.\n     * Contains the root index, earner, token leaves, and required proofs\n     * @param recipient The address recipient that receives the ERC20 rewards\n     * @dev only callable by the valid claimer, that is\n     * if claimerFor[claim.earner] is address(0) then only the earner can claim, otherwise only\n     * claimerFor[claim.earner] can claim the rewards.\n     * @dev This function may fail to execute with a large number of claims due to gas limits. Use a smaller array of claims if necessary.\n     */\n    function processClaims(RewardsMerkleClaim[] calldata claims, address recipient) external;\n\n    /**\n     * @notice Creates a new distribution root. activatedAt is set to block.timestamp + activationDelay\n     * @param root The merkle root of the distribution\n     * @param rewardsCalculationEndTimestamp The timestamp until which rewards have been calculated\n     * @dev Only callable by the rewardsUpdater\n     */\n    function submitRoot(bytes32 root, uint32 rewardsCalculationEndTimestamp) external;\n\n    /**\n     * @notice allow the rewardsUpdater to disable/cancel a pending root submission in case of an error\n     * @param rootIndex The index of the root to be disabled\n     */\n    function disableRoot(uint32 rootIndex) external;\n\n    /**\n     * @notice Sets the address of the entity that can call `processClaim` on behalf of the earner (msg.sender)\n     * @param claimer The address of the entity that can call `processClaim` on behalf of the earner\n     * @dev Only callable by the `earner`\n     */\n    function setClaimerFor(address claimer) external;\n\n    /**\n     * @notice Sets the delay in timestamp before a posted root can be claimed against\n     * @dev Only callable by the contract owner\n     * @param _activationDelay The new value for activationDelay\n     */\n    function setActivationDelay(uint32 _activationDelay) external;\n\n    /**\n     * @notice Sets the default split for all operators across all avss.\n     * @param split The default split for all operators across all avss in bips.\n     * @dev Only callable by the contract owner.\n     */\n    function setDefaultOperatorSplit(uint16 split) external;\n\n    /**\n     * @notice Sets the split for a specific operator for a specific avs\n     * @param operator The operator who is setting the split\n     * @param avs The avs for which the split is being set by the operator\n     * @param split The split for the operator for the specific avs in bips.\n     * @dev Only callable by the operator\n     * @dev Split has to be between 0 and 10000 bips (inclusive)\n     * @dev The split will be activated after the activation delay\n     */\n    function setOperatorAVSSplit(address operator, address avs, uint16 split) external;\n\n    /**\n     * @notice Sets the split for a specific operator for Programmatic Incentives.\n     * @param operator The operator on behalf of which the split is being set.\n     * @param split The split for the operator for Programmatic Incentives in bips.\n     * @dev Only callable by the operator\n     * @dev Split has to be between 0 and 10000 bips (inclusive)\n     * @dev The split will be activated after the activation delay\n     */\n    function setOperatorPISplit(address operator, uint16 split) external;\n\n    /**\n     * @notice Sets the permissioned `rewardsUpdater` address which can post new roots\n     * @dev Only callable by the contract owner\n     * @param _rewardsUpdater The address of the new rewardsUpdater\n     */\n    function setRewardsUpdater(address _rewardsUpdater) external;\n\n    /**\n     * @notice Sets the permissioned `rewardsForAllSubmitter` address which can submit createRewardsForAllSubmission\n     * @dev Only callable by the contract owner\n     * @param _submitter The address of the rewardsForAllSubmitter\n     * @param _newValue The new value for isRewardsForAllSubmitter\n     */\n    function setRewardsForAllSubmitter(address _submitter, bool _newValue) external;\n\n    /**\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\n     *\n     * @dev The domain separator will change in the event of a fork that changes the ChainID.\n     * @dev By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.\n     * for more detailed information please read EIP-712.\n     */\n    function domainSeparator() external view returns (bytes32);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/ISignatureUtils.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/**\n * @title The interface for common signature utilities.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface ISignatureUtils {\n    // @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for stack management.\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    // @notice Struct that bundles together a signature, a salt for uniqueness, and an expiration time for the signature. Used primarily for stack management.\n    struct SignatureWithSaltAndExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the salt used to generate the signature\n        bytes32 salt;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/ISlasher.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./IStrategyManager.sol\";\nimport \"./IDelegationManager.sol\";\n\n/**\n * @title Interface for the primary 'slashing' contract for EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice See the `Slasher` contract itself for implementation details.\n */\ninterface ISlasher {\n    // struct used to store information about the current state of an operator's obligations to middlewares they are serving\n    struct MiddlewareTimes {\n        // The update block for the middleware whose most recent update was earliest, i.e. the 'stalest' update out of all middlewares the operator is serving\n        uint32 stalestUpdateBlock;\n        // The latest 'serveUntilBlock' from all of the middleware that the operator is serving\n        uint32 latestServeUntilBlock;\n    }\n\n    // struct used to store details relevant to a single middleware that an operator has opted-in to serving\n    struct MiddlewareDetails {\n        // the block at which the contract begins being able to finalize the operator's registration with the service via calling `recordFirstStakeUpdate`\n        uint32 registrationMayBeginAtBlock;\n        // the block before which the contract is allowed to slash the user\n        uint32 contractCanSlashOperatorUntilBlock;\n        // the block at which the middleware's view of the operator's stake was most recently updated\n        uint32 latestUpdateBlock;\n    }\n\n    /// @notice Emitted when a middleware times is added to `operator`'s array.\n    event MiddlewareTimesAdded(\n        address operator, uint256 index, uint32 stalestUpdateBlock, uint32 latestServeUntilBlock\n    );\n\n    /// @notice Emitted when `operator` begins to allow `contractAddress` to slash them.\n    event OptedIntoSlashing(address indexed operator, address indexed contractAddress);\n\n    /// @notice Emitted when `contractAddress` signals that it will no longer be able to slash `operator` after the `contractCanSlashOperatorUntilBlock`.\n    event SlashingAbilityRevoked(\n        address indexed operator, address indexed contractAddress, uint32 contractCanSlashOperatorUntilBlock\n    );\n\n    /**\n     * @notice Emitted when `slashingContract` 'freezes' the `slashedOperator`.\n     * @dev The `slashingContract` must have permission to slash the `slashedOperator`, i.e. `canSlash(slasherOperator, slashingContract)` must return 'true'.\n     */\n    event OperatorFrozen(address indexed slashedOperator, address indexed slashingContract);\n\n    /// @notice Emitted when `previouslySlashedAddress` is 'unfrozen', allowing them to again move deposited funds within EigenLayer.\n    event FrozenStatusReset(address indexed previouslySlashedAddress);\n\n    /**\n     * @notice Gives the `contractAddress` permission to slash the funds of the caller.\n     * @dev Typically, this function must be called prior to registering for a middleware.\n     */\n    function optIntoSlashing(address contractAddress) external;\n\n    /**\n     * @notice Used for 'slashing' a certain operator.\n     * @param toBeFrozen The operator to be frozen.\n     * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\n     * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `optIntoSlashing`.\n     */\n    function freezeOperator(address toBeFrozen) external;\n\n    /**\n     * @notice Removes the 'frozen' status from each of the `frozenAddresses`\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function resetFrozenStatus(address[] calldata frozenAddresses) external;\n\n    /**\n     * @notice this function is a called by middlewares during an operator's registration to make sure the operator's stake at registration\n     *         is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\n     * @dev adds the middleware's slashing contract to the operator's linked list\n     */\n    function recordFirstStakeUpdate(address operator, uint32 serveUntilBlock) external;\n\n    /**\n     * @notice this function is a called by middlewares during a stake update for an operator (perhaps to free pending withdrawals)\n     *         to make sure the operator's stake at updateBlock is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param updateBlock the block for which the stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at updateBlock is slashable\n     * @param insertAfter the element of the operators linked list that the currently updating middleware should be inserted after\n     * @dev insertAfter should be calculated offchain before making the transaction that calls this. this is subject to race conditions,\n     *      but it is anticipated to be rare and not detrimental.\n     */\n    function recordStakeUpdate(\n        address operator,\n        uint32 updateBlock,\n        uint32 serveUntilBlock,\n        uint256 insertAfter\n    ) external;\n\n    /**\n     * @notice this function is a called by middlewares during an operator's deregistration to make sure the operator's stake at deregistration\n     *         is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\n     * @dev removes the middleware's slashing contract to the operator's linked list and revokes the middleware's (i.e. caller's) ability to\n     * slash `operator` once `serveUntil` is reached\n     */\n    function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntilBlock) external;\n\n    /// @notice The StrategyManager contract of EigenLayer\n    function strategyManager() external view returns (IStrategyManager);\n\n    /// @notice The DelegationManager contract of EigenLayer\n    function delegation() external view returns (IDelegationManager);\n\n    /**\n     * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\n     * slashing of their funds, and cannot cannot deposit or withdraw from the strategyManager until the slashing process is completed\n     * and the staker's status is reset (to 'unfrozen').\n     * @param staker The staker of interest.\n     * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\n     * to an operator who has their status set to frozen. Otherwise returns 'false'.\n     */\n    function isFrozen(address staker) external view returns (bool);\n\n    /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\n    function canSlash(address toBeSlashed, address slashingContract) external view returns (bool);\n\n    /// @notice Returns the block until which `serviceContract` is allowed to slash the `operator`.\n    function contractCanSlashOperatorUntilBlock(\n        address operator,\n        address serviceContract\n    ) external view returns (uint32);\n\n    /// @notice Returns the block at which the `serviceContract` last updated its view of the `operator`'s stake\n    function latestUpdateBlock(address operator, address serviceContract) external view returns (uint32);\n\n    /// @notice A search routine for finding the correct input value of `insertAfter` to `recordStakeUpdate` / `_updateMiddlewareList`.\n    function getCorrectValueForInsertAfter(address operator, uint32 updateBlock) external view returns (uint256);\n\n    /**\n     * @notice Returns 'true' if `operator` can currently complete a withdrawal started at the `withdrawalStartBlock`, with `middlewareTimesIndex` used\n     * to specify the index of a `MiddlewareTimes` struct in the operator's list (i.e. an index in `operatorToMiddlewareTimes[operator]`). The specified\n     * struct is consulted as proof of the `operator`'s ability (or lack thereof) to complete the withdrawal.\n     * This function will return 'false' if the operator cannot currently complete a withdrawal started at the `withdrawalStartBlock`, *or* in the event\n     * that an incorrect `middlewareTimesIndex` is supplied, even if one or more correct inputs exist.\n     * @param operator Either the operator who queued the withdrawal themselves, or if the withdrawing party is a staker who delegated to an operator,\n     * this address is the operator *who the staker was delegated to* at the time of the `withdrawalStartBlock`.\n     * @param withdrawalStartBlock The block number at which the withdrawal was initiated.\n     * @param middlewareTimesIndex Indicates an index in `operatorToMiddlewareTimes[operator]` to consult as proof of the `operator`'s ability to withdraw\n     * @dev The correct `middlewareTimesIndex` input should be computable off-chain.\n     */\n    function canWithdraw(\n        address operator,\n        uint32 withdrawalStartBlock,\n        uint256 middlewareTimesIndex\n    ) external returns (bool);\n\n    /**\n     * operator =>\n     *  [\n     *      (\n     *          the least recent update block of all of the middlewares it's serving/served,\n     *          latest time that the stake bonded at that update needed to serve until\n     *      )\n     *  ]\n     */\n    function operatorToMiddlewareTimes(\n        address operator,\n        uint256 arrayIndex\n    ) external view returns (MiddlewareTimes memory);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator].length`\n    function middlewareTimesLength(address operator) external view returns (uint256);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].stalestUpdateBlock`.\n    function getMiddlewareTimesIndexStalestUpdateBlock(address operator, uint32 index) external view returns (uint32);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].latestServeUntil`.\n    function getMiddlewareTimesIndexServeUntilBlock(address operator, uint32 index) external view returns (uint32);\n\n    /// @notice Getter function for fetching `_operatorToWhitelistedContractsByUpdate[operator].size`.\n    function operatorWhitelistedContractsLinkedListSize(address operator) external view returns (uint256);\n\n    /// @notice Getter function for fetching a single node in the operator's linked list (`_operatorToWhitelistedContractsByUpdate[operator]`).\n    function operatorWhitelistedContractsLinkedListEntry(\n        address operator,\n        address node\n    ) external view returns (bool, uint256, uint256);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IStrategy.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Minimal interface for an `Strategy` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Custom `Strategy` implementations may expand extensively on this interface.\n */\ninterface IStrategy {\n    /**\n     * @notice Used to emit an event for the exchange rate between 1 share and underlying token in a strategy contract\n     * @param rate is the exchange rate in wad 18 decimals\n     * @dev Tokens that do not have 18 decimals must have offchain services scale the exchange rate by the proper magnitude\n     */\n    event ExchangeRateEmitted(uint256 rate);\n\n    /**\n     * Used to emit the underlying token and its decimals on strategy creation\n     * @notice token\n     * @param token is the ERC20 token of the strategy\n     * @param decimals are the decimals of the ERC20 token in the strategy\n     */\n    event StrategyTokenSet(IERC20 token, uint8 decimals);\n\n    /**\n     * @notice Used to deposit tokens into this Strategy\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(IERC20 token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\n     * @param recipient is the address to receive the withdrawn funds\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * other functions, and individual share balances are recorded in the strategyManager as well.\n     */\n    function withdraw(address recipient, IERC20 token, uint256 amountShares) external;\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToShares(uint256 amountUnderlying) external returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current total shares of `user` in this strategy, by\n     * querying the `strategyManager` contract\n     */\n    function shares(address user) external view returns (uint256);\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view returns (uint256);\n\n    /// @notice The underlying token for shares in this Strategy\n    function underlyingToken() external view returns (IERC20);\n\n    /// @notice The total number of extant shares in this Strategy\n    function totalShares() external view returns (uint256);\n\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\n    function explanation() external view returns (string memory);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/interfaces/IStrategyManager.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./IStrategy.sol\";\nimport \"./ISlasher.sol\";\nimport \"./IDelegationManager.sol\";\nimport \"./IEigenPodManager.sol\";\n\n/**\n * @title Interface for the primary entrypoint for funds into EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice See the `StrategyManager` contract itself for implementation details.\n */\ninterface IStrategyManager {\n    /**\n     * @notice Emitted when a new deposit occurs on behalf of `staker`.\n     * @param staker Is the staker who is depositing funds into EigenLayer.\n     * @param strategy Is the strategy that `staker` has deposited into.\n     * @param token Is the token that `staker` deposited.\n     * @param shares Is the number of new shares `staker` has been granted in `strategy`.\n     */\n    event Deposit(address staker, IERC20 token, IStrategy strategy, uint256 shares);\n\n    /// @notice Emitted when `thirdPartyTransfersForbidden` is updated for a strategy and value by the owner\n    event UpdatedThirdPartyTransfersForbidden(IStrategy strategy, bool value);\n\n    /// @notice Emitted when the `strategyWhitelister` is changed\n    event StrategyWhitelisterChanged(address previousAddress, address newAddress);\n\n    /// @notice Emitted when a strategy is added to the approved list of strategies for deposit\n    event StrategyAddedToDepositWhitelist(IStrategy strategy);\n\n    /// @notice Emitted when a strategy is removed from the approved list of strategies for deposit\n    event StrategyRemovedFromDepositWhitelist(IStrategy strategy);\n\n    /**\n     * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `msg.sender`\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the staker\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\n     *\n     * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy.\n     */\n    function depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount) external returns (uint256 shares);\n\n    /**\n     * @notice Used for depositing an asset into the specified strategy with the resultant shares credited to `staker`,\n     * who must sign off on the action.\n     * Note that the assets are transferred out/from the `msg.sender`, not from the `staker`; this function is explicitly designed\n     * purely to help one address deposit 'for' another.\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the staker\n     * @param staker the staker that the deposited assets will be credited to\n     * @param expiry the timestamp at which the signature expires\n     * @param signature is a valid signature from the `staker`. either an ECDSA signature if the `staker` is an EOA, or data to forward\n     * following EIP-1271 if the `staker` is a contract\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev A signature is required for this function to eliminate the possibility of griefing attacks, specifically those\n     * targeting stakers who may be attempting to undelegate.\n     * @dev Cannot be called if thirdPartyTransfersForbidden is set to true for this strategy\n     *\n     *  WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy\n     */\n    function depositIntoStrategyWithSignature(\n        IStrategy strategy,\n        IERC20 token,\n        uint256 amount,\n        address staker,\n        uint256 expiry,\n        bytes memory signature\n    ) external returns (uint256 shares);\n\n    /// @notice Used by the DelegationManager to remove a Staker's shares from a particular strategy when entering the withdrawal queue\n    function removeShares(address staker, IStrategy strategy, uint256 shares) external;\n\n    /// @notice Used by the DelegationManager to award a Staker some shares that have passed through the withdrawal queue\n    function addShares(address staker, IERC20 token, IStrategy strategy, uint256 shares) external;\n\n    /// @notice Used by the DelegationManager to convert withdrawn shares to tokens and send them to a recipient\n    function withdrawSharesAsTokens(address recipient, IStrategy strategy, uint256 shares, IERC20 token) external;\n\n    /// @notice Returns the current shares of `user` in `strategy`\n    function stakerStrategyShares(address user, IStrategy strategy) external view returns (uint256 shares);\n\n    /**\n     * @notice Get all details on the staker's deposits and corresponding shares\n     * @param staker The staker of interest, whose deposits this function will fetch\n     * @return (staker's strategies, shares in these strategies)\n     */\n    function getDeposits(address staker) external view returns (IStrategy[] memory, uint256[] memory);\n\n    /// @notice Simple getter function that returns `stakerStrategyList[staker].length`.\n    function stakerStrategyListLength(address staker) external view returns (uint256);\n\n    /**\n     * @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\n     * @param strategiesToWhitelist Strategies that will be added to the `strategyIsWhitelistedForDeposit` mapping (if they aren't in it already)\n     * @param thirdPartyTransfersForbiddenValues bool values to set `thirdPartyTransfersForbidden` to for each strategy\n     */\n    function addStrategiesToDepositWhitelist(\n        IStrategy[] calldata strategiesToWhitelist,\n        bool[] calldata thirdPartyTransfersForbiddenValues\n    ) external;\n\n    /**\n     * @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\n     * @param strategiesToRemoveFromWhitelist Strategies that will be removed to the `strategyIsWhitelistedForDeposit` mapping (if they are in it)\n     */\n    function removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) external;\n\n    /**\n     * If true for a strategy, a user cannot depositIntoStrategyWithSignature into that strategy for another staker\n     * and also when performing DelegationManager.queueWithdrawals, a staker can only withdraw to themselves.\n     * Defaulted to false for all existing strategies.\n     * @param strategy The strategy to set `thirdPartyTransfersForbidden` value to\n     * @param value bool value to set `thirdPartyTransfersForbidden` to\n     */\n    function setThirdPartyTransfersForbidden(IStrategy strategy, bool value) external;\n\n    /// @notice Returns the single, central Delegation contract of EigenLayer\n    function delegation() external view returns (IDelegationManager);\n\n    /// @notice Returns the single, central Slasher contract of EigenLayer\n    function slasher() external view returns (ISlasher);\n\n    /// @notice Returns the EigenPodManager contract of EigenLayer\n    function eigenPodManager() external view returns (IEigenPodManager);\n\n    /// @notice Returns the address of the `strategyWhitelister`\n    function strategyWhitelister() external view returns (address);\n\n    /// @notice Returns bool for whether or not `strategy` is whitelisted for deposit\n    function strategyIsWhitelistedForDeposit(IStrategy strategy) external view returns (bool);\n\n    /**\n     * @notice Owner-only function to change the `strategyWhitelister` address.\n     * @param newStrategyWhitelister new address for the `strategyWhitelister`.\n     */\n    function setStrategyWhitelister(address newStrategyWhitelister) external;\n\n    /**\n     * @notice Returns bool for whether or not `strategy` enables credit transfers. i.e enabling\n     * depositIntoStrategyWithSignature calls or queueing withdrawals to a different address than the staker.\n     */\n    function thirdPartyTransfersForbidden(IStrategy strategy) external view returns (bool);\n\n    /**\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\n     * @dev The domain separator will change in the event of a fork that changes the ChainID.\n     */\n    function domainSeparator() external view returns (bytes32);\n}\n"
      },
      "eigenlayer-contracts/src/contracts/libraries/BeaconChainProofs.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    /// @notice Heights of various merkle trees in the beacon chain\n    /// - beaconBlockRoot\n    /// |                                             HEIGHT: BEACON_BLOCK_HEADER_TREE_HEIGHT\n    /// -- beaconStateRoot\n    /// |                                             HEIGHT: BEACON_STATE_TREE_HEIGHT\n    /// validatorContainerRoot, balanceContainerRoot\n    /// |                       |                     HEIGHT: BALANCE_TREE_HEIGHT\n    /// |                       individual balances\n    /// |                                             HEIGHT: VALIDATOR_TREE_HEIGHT\n    /// individual validators\n    uint256 internal constant BEACON_BLOCK_HEADER_TREE_HEIGHT = 3;\n    uint256 internal constant BEACON_STATE_TREE_HEIGHT = 5;\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n\n    /// @notice Index of the beaconStateRoot in the `BeaconBlockHeader` container\n    ///\n    /// BeaconBlockHeader = [..., state_root, ...]\n    ///                      0...      3\n    ///\n    /// (See https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader)\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n\n    /// @notice Indices for fields in the `BeaconState` container\n    ///\n    /// BeaconState = [..., validators, balances, ...]\n    ///                0...     11         12\n    ///\n    /// (See https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#beaconstate)\n    uint256 internal constant VALIDATOR_CONTAINER_INDEX = 11;\n    uint256 internal constant BALANCE_CONTAINER_INDEX = 12;\n\n    /// @notice Number of fields in the `Validator` container\n    /// (See https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator)\n    uint256 internal constant VALIDATOR_FIELDS_LENGTH = 8;\n\n    /// @notice Indices for fields in the `Validator` container\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_ACTIVATION_EPOCH_INDEX = 5;\n    uint256 internal constant VALIDATOR_EXIT_EPOCH_INDEX = 6;\n\n    /// @notice Slot/Epoch timings\n    uint64 internal constant SECONDS_PER_SLOT = 12;\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\n    uint64 internal constant SECONDS_PER_EPOCH = SLOTS_PER_EPOCH * SECONDS_PER_SLOT;\n\n    /// @notice `FAR_FUTURE_EPOCH` is used as the default value for certain `Validator`\n    /// fields when a `Validator` is first created on the beacon chain\n    uint64 internal constant FAR_FUTURE_EPOCH = type(uint64).max;\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n    /// @notice Contains a beacon state root and a merkle proof verifying its inclusion under a beacon block root\n    struct StateRootProof {\n        bytes32 beaconStateRoot;\n        bytes proof;\n    }\n\n    /// @notice Contains a validator's fields and a merkle proof of their inclusion under a beacon state root\n    struct ValidatorProof {\n        bytes32[] validatorFields;\n        bytes proof;\n    }\n\n    /// @notice Contains a beacon balance container root and a proof of this root under a beacon block root\n    struct BalanceContainerProof {\n        bytes32 balanceContainerRoot;\n        bytes proof;\n    }\n\n    /// @notice Contains a validator balance root and a proof of its inclusion under a balance container root\n    struct BalanceProof {\n        bytes32 pubkeyHash;\n        bytes32 balanceRoot;\n        bytes proof;\n    }\n\n    /**\n     *\n     *              VALIDATOR FIELDS -> BEACON STATE ROOT -> BEACON BLOCK ROOT\n     *\n     */\n\n    /// @notice Verify a merkle proof of the beacon state root against a beacon block root\n    /// @param beaconBlockRoot merkle root of the beacon block\n    /// @param proof the beacon state root and merkle proof of its inclusion under `beaconBlockRoot`\n    function verifyStateRoot(bytes32 beaconBlockRoot, StateRootProof calldata proof) internal view {\n        require(\n            proof.proof.length == 32 * (BEACON_BLOCK_HEADER_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyStateRoot: Proof has incorrect length\"\n        );\n\n        /// This merkle proof verifies the `beaconStateRoot` under the `beaconBlockRoot`\n        /// - beaconBlockRoot\n        /// |                            HEIGHT: BEACON_BLOCK_HEADER_TREE_HEIGHT\n        /// -- beaconStateRoot\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: proof.proof,\n                root: beaconBlockRoot,\n                leaf: proof.beaconStateRoot,\n                index: STATE_ROOT_INDEX\n            }),\n            \"BeaconChainProofs.verifyStateRoot: Invalid state root merkle proof\"\n        );\n    }\n\n    /// @notice Verify a merkle proof of a validator container against a `beaconStateRoot`\n    /// @dev This proof starts at a validator's container root, proves through the validator container root,\n    /// and continues proving to the root of the `BeaconState`\n    /// @dev See https://eth2book.info/capella/part3/containers/dependencies/#validator for info on `Validator` containers\n    /// @dev See https://eth2book.info/capella/part3/containers/state/#beaconstate for info on `BeaconState` containers\n    /// @param beaconStateRoot merkle root of the `BeaconState` container\n    /// @param validatorFields an individual validator's fields. These are merklized to form a `validatorRoot`,\n    /// which is used as the leaf to prove against `beaconStateRoot`\n    /// @param validatorFieldsProof a merkle proof of inclusion of `validatorFields` under `beaconStateRoot`\n    /// @param validatorIndex the validator's unique index\n    function verifyValidatorFields(\n        bytes32 beaconStateRoot,\n        bytes32[] calldata validatorFields,\n        bytes calldata validatorFieldsProof,\n        uint40 validatorIndex\n    ) internal view {\n        require(\n            validatorFields.length == VALIDATOR_FIELDS_LENGTH,\n            \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\"\n        );\n\n        /// Note: the reason we use `VALIDATOR_TREE_HEIGHT + 1` here is because the merklization process for\n        /// this container includes hashing the root of the validator tree with the length of the validator list\n        require(\n            validatorFieldsProof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\"\n        );\n\n        // Merkleize `validatorFields` to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        /// This proof combines two proofs, so its index accounts for the relative position of leaves in two trees:\n        /// - beaconStateRoot\n        /// |                            HEIGHT: BEACON_STATE_TREE_HEIGHT\n        /// -- validatorContainerRoot\n        /// |                            HEIGHT: VALIDATOR_TREE_HEIGHT + 1\n        /// ---- validatorRoot\n        uint256 index = (VALIDATOR_CONTAINER_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: validatorFieldsProof,\n                root: beaconStateRoot,\n                leaf: validatorRoot,\n                index: index\n            }),\n            \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\"\n        );\n    }\n\n    /**\n     *\n     *          VALIDATOR BALANCE -> BALANCE CONTAINER ROOT -> BEACON BLOCK ROOT\n     *\n     */\n\n    /// @notice Verify a merkle proof of the beacon state's balances container against the beacon block root\n    /// @dev This proof starts at the balance container root, proves through the beacon state root, and\n    /// continues proving through the beacon block root. As a result, this proof will contain elements\n    /// of a `StateRootProof` under the same block root, with the addition of proving the balances field\n    /// within the beacon state.\n    /// @dev This is used to make checkpoint proofs more efficient, as a checkpoint will verify multiple balances\n    /// against the same balance container root.\n    /// @param beaconBlockRoot merkle root of the beacon block\n    /// @param proof a beacon balance container root and merkle proof of its inclusion under `beaconBlockRoot`\n    function verifyBalanceContainer(bytes32 beaconBlockRoot, BalanceContainerProof calldata proof) internal view {\n        require(\n            proof.proof.length == 32 * (BEACON_BLOCK_HEADER_TREE_HEIGHT + BEACON_STATE_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyBalanceContainer: Proof has incorrect length\"\n        );\n\n        /// This proof combines two proofs, so its index accounts for the relative position of leaves in two trees:\n        /// - beaconBlockRoot\n        /// |                            HEIGHT: BEACON_BLOCK_HEADER_TREE_HEIGHT\n        /// -- beaconStateRoot\n        /// |                            HEIGHT: BEACON_STATE_TREE_HEIGHT\n        /// ---- balancesContainerRoot\n        uint256 index = (STATE_ROOT_INDEX << (BEACON_STATE_TREE_HEIGHT)) | BALANCE_CONTAINER_INDEX;\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: proof.proof,\n                root: beaconBlockRoot,\n                leaf: proof.balanceContainerRoot,\n                index: index\n            }),\n            \"BeaconChainProofs.verifyBalanceContainer: invalid balance container proof\"\n        );\n    }\n\n    /// @notice Verify a merkle proof of a validator's balance against the beacon state's `balanceContainerRoot`\n    /// @param balanceContainerRoot the merkle root of all validators' current balances\n    /// @param validatorIndex the index of the validator whose balance we are proving\n    /// @param proof the validator's associated balance root and a merkle proof of inclusion under `balanceContainerRoot`\n    /// @return validatorBalanceGwei the validator's current balance (in gwei)\n    function verifyValidatorBalance(\n        bytes32 balanceContainerRoot,\n        uint40 validatorIndex,\n        BalanceProof calldata proof\n    ) internal view returns (uint64 validatorBalanceGwei) {\n        /// Note: the reason we use `BALANCE_TREE_HEIGHT + 1` here is because the merklization process for\n        /// this container includes hashing the root of the balances tree with the length of the balances list\n        require(\n            proof.proof.length == 32 * (BALANCE_TREE_HEIGHT + 1),\n            \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\"\n        );\n\n        /// When merkleized, beacon chain balances are combined into groups of 4 called a `balanceRoot`. The merkle\n        /// proof here verifies that this validator's `balanceRoot` is included in the `balanceContainerRoot`\n        /// - balanceContainerRoot\n        /// |                            HEIGHT: BALANCE_TREE_HEIGHT\n        /// -- balanceRoot\n        uint256 balanceIndex = uint256(validatorIndex / 4);\n\n        require(\n            Merkle.verifyInclusionSha256({\n                proof: proof.proof,\n                root: balanceContainerRoot,\n                leaf: proof.balanceRoot,\n                index: balanceIndex\n            }),\n            \"BeaconChainProofs.verifyValidatorBalance: Invalid merkle proof\"\n        );\n\n        /// Extract the individual validator's balance from the `balanceRoot`\n        return getBalanceAtIndex(proof.balanceRoot, validatorIndex);\n    }\n\n    /**\n     * @notice Parses a balanceRoot to get the uint64 balance of a validator.\n     * @dev During merkleization of the beacon state balance tree, four uint64 values are treated as a single\n     * leaf in the merkle tree. We use validatorIndex % 4 to determine which of the four uint64 values to\n     * extract from the balanceRoot.\n     * @param balanceRoot is the combination of 4 validator balances being proven for\n     * @param validatorIndex is the index of the validator being proven for\n     * @return The validator's balance, in Gwei\n     */\n    function getBalanceAtIndex(bytes32 balanceRoot, uint40 validatorIndex) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        return Endian.fromLittleEndianUint64(bytes32((uint256(balanceRoot) << bitShiftAmount)));\n    }\n\n    /// @notice Indices for fields in the `Validator` container:\n    /// 0: pubkey\n    /// 1: withdrawal credentials\n    /// 2: effective balance\n    /// 3: slashed?\n    /// 4: activation eligibility epoch\n    /// 5: activation epoch\n    /// 6: exit epoch\n    /// 7: withdrawable epoch\n    ///\n    /// (See https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator)\n\n    /// @dev Retrieves a validator's pubkey hash\n    function getPubkeyHash(bytes32[] memory validatorFields) internal pure returns (bytes32) {\n        return validatorFields[VALIDATOR_PUBKEY_INDEX];\n    }\n\n    /// @dev Retrieves a validator's withdrawal credentials\n    function getWithdrawalCredentials(bytes32[] memory validatorFields) internal pure returns (bytes32) {\n        return validatorFields[VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX];\n    }\n\n    /// @dev Retrieves a validator's effective balance (in gwei)\n    function getEffectiveBalanceGwei(bytes32[] memory validatorFields) internal pure returns (uint64) {\n        return Endian.fromLittleEndianUint64(validatorFields[VALIDATOR_BALANCE_INDEX]);\n    }\n\n    /// @dev Retrieves a validator's activation epoch\n    function getActivationEpoch(bytes32[] memory validatorFields) internal pure returns (uint64) {\n        return Endian.fromLittleEndianUint64(validatorFields[VALIDATOR_ACTIVATION_EPOCH_INDEX]);\n    }\n\n    /// @dev Retrieves true IFF a validator is marked slashed\n    function isValidatorSlashed(bytes32[] memory validatorFields) internal pure returns (bool) {\n        return validatorFields[VALIDATOR_SLASHED_INDEX] != 0;\n    }\n\n    /// @dev Retrieves a validator's exit epoch\n    function getExitEpoch(bytes32[] memory validatorFields) internal pure returns (uint64) {\n        return Endian.fromLittleEndianUint64(validatorFields[VALIDATOR_EXIT_EPOCH_INDEX]);\n    }\n}\n"
      },
      "eigenlayer-contracts/src/contracts/libraries/Endian.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary Endian {\n    /**\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\n     * @return n The big endian-formatted uint64\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits), but it is immediately truncated to a uint64 (i.e. 64 bits)\n     * through a right-shift/shr operation.\n     */\n    function fromLittleEndianUint64(bytes32 lenum) internal pure returns (uint64 n) {\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\n        n = uint64(uint256(lenum >> 192));\n        // forgefmt: disable-next-item\n        return (n >> 56) | \n            ((0x00FF000000000000 & n) >> 40) | \n            ((0x0000FF0000000000 & n) >> 24) | \n            ((0x000000FF00000000 & n) >> 8)  | \n            ((0x00000000FF000000 & n) << 8)  | \n            ((0x0000000000FF0000 & n) << 24) | \n            ((0x000000000000FF00 & n) << 40) | \n            ((0x00000000000000FF & n) << 56);\n    }\n}\n"
      },
      "eigenlayer-contracts/src/contracts/libraries/Merkle.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * @dev If the proof length is 0 then the leaf hash is returned.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bytes32) {\n        require(proof.length % 32 == 0, \"Merkle.processInclusionProofKeccak: proof length should be a multiple of 32\");\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     *\n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(\n        bytes memory proof,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bytes32) {\n        require(\n            proof.length != 0 && proof.length % 32 == 0,\n            \"Merkle.processInclusionProofSha256: proof length should be a non-zero multiple of 32\"\n        );\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            if (index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) { revert(0, 0) }\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) { revert(0, 0) }\n                    index := div(index, 2)\n                }\n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     * @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     *  @param leaves the leaves of the merkle tree\n     *  @return The computed Merkle root of the tree.\n     *  @dev A pre-condition to this function is that leaves.length is a power of two.  If not, the function will merkleize the inputs incorrectly.\n     */\n    function merkleizeSha256(bytes32[] memory leaves) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint256 i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2 * i], leaves[2 * i + 1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint256 i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2 * i], layer[2 * i + 1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "viaIR": true,
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "storageLayout"
          ],
          "": [
            "ast"
          ]
        }
      }
    }
  }